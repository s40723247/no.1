<?xml version="1.0" encoding="utf-8"?>
<!-- Created by Leo: http://leoeditor.com/leo_toc.html -->
<leo_file xmlns:leo="http://leoeditor.com/namespaces/leo-python-editor/1.1" >
<leo_header file_format="2" tnodes="0" max_tnode_index="0" clone_windows="0"/>
<globals body_outline_ratio="0.5" body_secondary_ratio="0.5">
	<global_window_position top="50" left="50" height="500" width="700"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="leo.20181129164111.1"><vh>@button https-server</vh></v>
<v t="leo.20181129163546.1"><vh>@clean game1.html</vh>
<v t="leo.20181129164322.1"><vh>&lt;&lt;game_title&gt;&gt;</vh></v>
<v t="leo.20181129163716.1"><vh>game body</vh></v>
</v>
<v t="leo.20181224134424.1"><vh>@edit gg.html</vh></v>
<v t="leo.20181129165714.1"><vh>@clean game2.html</vh>
<v t="leo.20181129165714.2"><vh>&lt;&lt;game_title&gt;&gt;</vh></v>
<v t="leo.20181129165714.3"><vh>game body</vh></v>
</v>
<v t="leo.20181129163741.1"><vh>@edit bunny.html</vh></v>
<v t="leo.20181129163342.2"><vh>@edit spacewar.html</vh></v>
<v t="leo.20190103224422.1"><vh>@edit snake.html</vh></v>
<v t="leo.20181129165000.1"><vh>@edit template.html</vh></v>
<v t="leo.20181129171546.1"><vh>@path static/ggame</vh>
<v t="leo.20181129171705.1"><vh>@edit __init__.py</vh></v>
<v t="leo.20181129171705.2"><vh>@clean app.py</vh>
<v t="leo.20181129171705.23"><vh>Declarations (app.py)</vh></v>
<v t="leo.20181129171705.24" a="E"><vh>class App</vh>
<v t="leo.20181129171705.25"><vh>App.__init__</vh></v>
<v t="leo.20181129171705.26"><vh>App._routeEvent</vh></v>
<v t="leo.20181129171705.27"><vh>App._keyEvent</vh></v>
<v t="leo.20181129171705.28"><vh>App._mouseEvent</vh></v>
<v t="leo.20181129171705.29"><vh>App._add</vh></v>
<v t="leo.20181129171705.30"><vh>App._remove</vh></v>
<v t="leo.20181129171705.31"><vh>App._animate</vh></v>
<v t="leo.20181129171705.32"><vh>App._destroy</vh></v>
<v t="leo.20181129171705.33"><vh>App.listenKeyEvent</vh></v>
<v t="leo.20181129171705.34"><vh>App.listenMouseEvent</vh></v>
<v t="leo.20181129171705.35"><vh>App.unlistenKeyEvent</vh></v>
<v t="leo.20181129171705.36"><vh>App.unlistenMouseEvent</vh></v>
<v t="leo.20181129171705.37"><vh>App.getSpritesbyClass</vh></v>
<v t="leo.20181129171705.38"><vh>App.step</vh></v>
<v t="leo.20181129171705.39"><vh>App.run</vh></v>
</v>
</v>
<v t="leo.20181129171705.3"><vh>@clean asset.py</vh>
<v t="leo.20181129171705.40"><vh>Declarations (asset.py)</vh></v>
<v t="leo.20181129171705.41"><vh>class Frame</vh>
<v t="leo.20181129171705.42"><vh>Frame.__init__</vh></v>
<v t="leo.20181129171705.43"><vh>Frame.x</vh></v>
<v t="leo.20181129171705.44"><vh>Frame.x</vh></v>
<v t="leo.20181129171705.45"><vh>Frame.y</vh></v>
<v t="leo.20181129171705.46"><vh>Frame.y</vh></v>
<v t="leo.20181129171705.47"><vh>Frame.w</vh></v>
<v t="leo.20181129171705.48"><vh>Frame.w</vh></v>
<v t="leo.20181129171705.49"><vh>Frame.h</vh></v>
<v t="leo.20181129171705.50"><vh>Frame.h</vh></v>
<v t="leo.20181129171705.51"><vh>Frame.center</vh></v>
<v t="leo.20181129171705.52"><vh>Frame.center</vh></v>
</v>
<v t="leo.20181129171705.53"><vh>class _Asset</vh>
<v t="leo.20181129171705.54"><vh>_Asset.__init__</vh></v>
<v t="leo.20181129171705.55"><vh>_Asset.GFX</vh></v>
<v t="leo.20181129171705.56"><vh>_Asset.GFX</vh></v>
<v t="leo.20181129171705.57"><vh>_Asset.__len__</vh></v>
<v t="leo.20181129171705.58"><vh>_Asset.__getitem__</vh></v>
<v t="leo.20181129171705.59"><vh>_Asset.__setitem__</vh></v>
<v t="leo.20181129171705.60"><vh>_Asset.__iter__</vh></v>
<v t="leo.20181129171705.61"><vh>_Asset.destroy</vh></v>
</v>
<v t="leo.20181129171705.62"><vh>class ImageAsset</vh>
<v t="leo.20181129171705.63"><vh>ImageAsset.__init__</vh></v>
<v t="leo.20181129171705.64"><vh>ImageAsset._subframe</vh></v>
<v t="leo.20181129171705.65"><vh>ImageAsset.append</vh></v>
</v>
<v t="leo.20181129171705.66"><vh>class Color</vh>
<v t="leo.20181129171705.67"><vh>Color.__init__</vh></v>
<v t="leo.20181129171705.68"><vh>Color.__eq__</vh></v>
<v t="leo.20181129171705.69"><vh>Color.__repr__</vh></v>
</v>
<v t="leo.20181129171705.70"><vh>class LineStyle</vh>
<v t="leo.20181129171705.71"><vh>LineStyle.__init__</vh></v>
<v t="leo.20181129171705.72"><vh>LineStyle.__eq__</vh></v>
<v t="leo.20181129171705.73"><vh>LineStyle.__repr__</vh></v>
</v>
<v t="leo.20181129171705.74" a="E"><vh>class _GraphicsAsset</vh>
<v t="leo.20181129171705.75"><vh>_GraphicsAsset.__init__</vh></v>
</v>
<v t="leo.20181129171705.76"><vh>class _CurveAsset</vh>
<v t="leo.20181129171705.77"><vh>_CurveAsset.__init__</vh></v>
</v>
<v t="leo.20181129171705.78"><vh>class _ShapeAsset</vh>
<v t="leo.20181129171705.79"><vh>_ShapeAsset.__init__</vh></v>
</v>
<v t="leo.20181129171705.80"><vh>class RectangleAsset</vh>
<v t="leo.20181129171705.81"><vh>RectangleAsset.__init__</vh></v>
</v>
<v t="leo.20181129171705.82"><vh>class CircleAsset</vh>
<v t="leo.20181129171705.83"><vh>CircleAsset.__init__</vh></v>
</v>
<v t="leo.20181129171705.84"><vh>class EllipseAsset</vh>
<v t="leo.20181129171705.85"><vh>EllipseAsset.__init__</vh></v>
</v>
<v t="leo.20181129171705.86"><vh>class PolygonAsset</vh>
<v t="leo.20181129171705.87"><vh>PolygonAsset.__init__</vh></v>
</v>
<v t="leo.20181129171705.88" a="E"><vh>class LineAsset</vh>
<v t="leo.20181129171705.89"><vh>LineAsset.__init__</vh></v>
</v>
<v t="leo.20181129171705.90"><vh>class TextAsset</vh>
<v t="leo.20181129171705.91"><vh>TextAsset.__init__</vh></v>
<v t="leo.20181129171705.92"><vh>TextAsset._clone</vh></v>
<v t="leo.20181129171705.93"><vh>TextAsset.width</vh></v>
<v t="leo.20181129171705.94"><vh>TextAsset.height</vh></v>
</v>
</v>
<v t="leo.20181129171705.4"><vh>@clean astro.py</vh>
<v t="leo.20181129171705.95"><vh>Declarations (astro.py)</vh></v>
<v t="leo.20181129171705.96"><vh>class Rocket</vh>
<v t="leo.20181129171705.97"><vh>Rocket.__init__</vh></v>
<v t="leo.20181129171705.98"><vh>Rocket.getthrust</vh></v>
<v t="leo.20181129171705.99"><vh>Rocket.getmass</vh></v>
<v t="leo.20181129171705.100"><vh>Rocket.getheading</vh></v>
<v t="leo.20181129171705.101"><vh>Rocket.gettimezoom</vh></v>
<v t="leo.20181129171705.102"><vh>Rocket.addStatusReport</vh></v>
<v t="leo.20181129171705.103"><vh>Rocket.velocityText</vh></v>
<v t="leo.20181129171705.104"><vh>Rocket.accelerationText</vh></v>
<v t="leo.20181129171705.105"><vh>Rocket.courseDegreesText</vh></v>
<v t="leo.20181129171705.106"><vh>Rocket.thrustText</vh></v>
<v t="leo.20181129171705.107"><vh>Rocket.massText</vh></v>
<v t="leo.20181129171705.108"><vh>Rocket.trueAnomalyDegreesText</vh></v>
<v t="leo.20181129171705.109"><vh>Rocket.trueAnomalyRadiansText</vh></v>
<v t="leo.20181129171705.110"><vh>Rocket.altitudeText</vh></v>
<v t="leo.20181129171705.111"><vh>Rocket.radiusText</vh></v>
<v t="leo.20181129171705.112"><vh>Rocket.scaleText</vh></v>
<v t="leo.20181129171705.113"><vh>Rocket.timeZoomText</vh></v>
<v t="leo.20181129171705.114"><vh>Rocket.shipTimeText</vh></v>
<v t="leo.20181129171705.115"><vh>Rocket.dynamics</vh></v>
<v t="leo.20181129171705.116"><vh>Rocket.fr</vh></v>
<v t="leo.20181129171705.117"><vh>Rocket.ar</vh></v>
<v t="leo.20181129171705.118"><vh>Rocket.vadd</vh></v>
<v t="leo.20181129171705.119"><vh>Rocket.vmul</vh></v>
<v t="leo.20181129171705.120"><vh>Rocket.vmag</vh></v>
<v t="leo.20181129171705.121"><vh>Rocket.fgrav</vh></v>
<v t="leo.20181129171705.122"><vh>Rocket.turn</vh></v>
<v t="leo.20181129171705.123"><vh>Rocket._getposition</vh></v>
<v t="leo.20181129171705.124"><vh>Rocket.xyposition</vh></v>
<v t="leo.20181129171705.125"><vh>Rocket.xyposition</vh></v>
<v t="leo.20181129171705.126"><vh>Rocket.tanomalyd</vh></v>
<v t="leo.20181129171705.127"><vh>Rocket.tanomalyd</vh></v>
<v t="leo.20181129171705.128"><vh>Rocket.altitude</vh></v>
<v t="leo.20181129171705.129"><vh>Rocket.altitude</vh></v>
<v t="leo.20181129171705.130"><vh>Rocket.velocity</vh></v>
<v t="leo.20181129171705.131"><vh>Rocket.acceleration</vh></v>
<v t="leo.20181129171705.132"><vh>Rocket.tanomaly</vh></v>
<v t="leo.20181129171705.133"><vh>Rocket.tanomaly</vh></v>
<v t="leo.20181129171705.134"><vh>Rocket.r</vh></v>
</v>
<v t="leo.20181129171705.135"><vh>class Planet</vh>
<v t="leo.20181129171705.136"><vh>Planet.__init__</vh></v>
<v t="leo.20181129171705.137"><vh>Planet.run</vh></v>
</v>
</v>
<v t="leo.20181129171705.5"><vh>@clean circle.py</vh>
<v t="leo.20181129171705.138"><vh>Declarations (circle.py)</vh></v>
<v t="leo.20181129171705.139"><vh>class Circle</vh>
<v t="leo.20181129171705.140"><vh>Circle.__init__</vh></v>
<v t="leo.20181129171705.141"><vh>Circle._buildAsset</vh></v>
<v t="leo.20181129171705.142"><vh>Circle._buildPolygon</vh></v>
<v t="leo.20181129171705.143"><vh>Circle._addBoundaryVertices</vh></v>
<v t="leo.20181129171705.144"><vh>Circle._sgn</vh></v>
<v t="leo.20181129171705.145"><vh>Circle._findIntercepts</vh></v>
<v t="leo.20181129171705.146"><vh>Circle.center</vh></v>
<v t="leo.20181129171705.147"><vh>Circle.center</vh></v>
<v t="leo.20181129171705.148"><vh>Circle.radius</vh></v>
<v t="leo.20181129171705.149"><vh>Circle.radius</vh></v>
<v t="leo.20181129171705.150"><vh>Circle.step</vh></v>
<v t="leo.20181129171705.151"><vh>Circle.physicalPointTouching</vh></v>
<v t="leo.20181129171705.152"><vh>Circle.translate</vh></v>
</v>
</v>
<v t="leo.20181129171705.6"><vh>@clean event.py</vh>
<v t="leo.20181129171706.1"><vh>Declarations (event.py)</vh></v>
<v t="leo.20181129171706.2" a="E"><vh>class _Event</vh>
<v t="leo.20181129171706.3"><vh>_Event.__init__</vh></v>
</v>
<v t="leo.20181129171706.4" a="E"><vh>class MouseEvent</vh>
<v t="leo.20181129171706.5"><vh>MouseEvent.__init__</vh></v>
</v>
<v t="leo.20181129171706.6"><vh>class KeyEvent</vh>
<v t="leo.20181129171706.7"><vh>KeyEvent.__init__</vh></v>
</v>
</v>
<v t="leo.20181129171705.7"><vh>@clean headlessdeps.py</vh>
<v t="leo.20181129171706.8"><vh>module_exists (headlessdeps.py)</vh></v>
</v>
<v t="leo.20181129171705.8"><vh>@clean indicator.py</vh>
<v t="leo.20181129171706.9"><vh>Declarations (indicator.py)</vh></v>
<v t="leo.20181129171706.10"><vh>class ImageIndicator</vh>
<v t="leo.20181129171706.11"><vh>ImageIndicator.__init__</vh></v>
<v t="leo.20181129171706.12"><vh>ImageIndicator._buildAsset</vh></v>
<v t="leo.20181129171706.13"><vh>ImageIndicator.physicalPointTouching</vh></v>
<v t="leo.20181129171706.14"><vh>ImageIndicator.translate</vh></v>
</v>
<v t="leo.20181129171706.15"><vh>class LEDIndicator</vh>
<v t="leo.20181129171706.16"><vh>LEDIndicator.__init__</vh></v>
</v>
</v>
<v t="leo.20181129171705.9"><vh>@clean input.py</vh>
<v t="leo.20181129171706.17"><vh>Declarations (input.py)</vh></v>
<v t="leo.20181129171706.18"><vh>class InputNumeric</vh>
<v t="leo.20181129171706.19"><vh>InputNumeric.__init__</vh></v>
<v t="leo.20181129171706.20"><vh>InputNumeric._textValue</vh></v>
<v t="leo.20181129171706.21"><vh>InputNumeric._updateText</vh></v>
<v t="leo.20181129171706.22"><vh>InputNumeric.processEvent</vh></v>
<v t="leo.20181129171706.23"><vh>InputNumeric.select</vh></v>
<v t="leo.20181129171706.24"><vh>InputNumeric.unselect</vh></v>
<v t="leo.20181129171706.25"><vh>InputNumeric.__call__</vh></v>
</v>
<v t="leo.20181129171706.26"><vh>class InputButton</vh>
<v t="leo.20181129171706.27"><vh>InputButton.__init__</vh></v>
<v t="leo.20181129171706.28"><vh>InputButton._buildAsset</vh></v>
<v t="leo.20181129171706.29"><vh>InputButton.select</vh></v>
<v t="leo.20181129171706.30"><vh>InputButton.unselect</vh></v>
</v>
</v>
<v t="leo.20181129171705.10"><vh>@clean inputpoint.py</vh>
<v t="leo.20181129171706.31"><vh>Declarations (inputpoint.py)</vh></v>
<v t="leo.20181129171706.32"><vh>class InputImageButton</vh>
<v t="leo.20181129171706.33"><vh>InputImageButton.__init__</vh></v>
<v t="leo.20181129171706.34"><vh>InputImageButton.select</vh></v>
<v t="leo.20181129171706.35"><vh>InputImageButton.unselect</vh></v>
<v t="leo.20181129171706.36"><vh>InputImageButton.__call__</vh></v>
</v>
<v t="leo.20181129171706.37"><vh>class InputImageToggle</vh>
<v t="leo.20181129171706.38"><vh>InputImageToggle.__init__</vh></v>
<v t="leo.20181129171706.39"><vh>InputImageToggle.select</vh></v>
<v t="leo.20181129171706.40"><vh>InputImageToggle.__call__</vh></v>
</v>
<v t="leo.20181129171706.41"><vh>class MetalToggle</vh>
<v t="leo.20181129171706.42"><vh>MetalToggle.__init__</vh></v>
</v>
<v t="leo.20181129171706.43"><vh>class GlassButton</vh>
<v t="leo.20181129171706.44"><vh>GlassButton.__init__</vh></v>
</v>
</v>
<v t="leo.20181129171705.11"><vh>@clean label.py</vh>
<v t="leo.20181129171706.45"><vh>Declarations (label.py)</vh></v>
<v t="leo.20181129171706.46"><vh>class Label</vh>
<v t="leo.20181129171706.47"><vh>Label.__init__</vh></v>
<v t="leo.20181129171706.48"><vh>Label._buildAsset</vh></v>
<v t="leo.20181129171706.49"><vh>Label.__call__</vh></v>
<v t="leo.20181129171706.50"><vh>Label.physicalPointTouching</vh></v>
<v t="leo.20181129171706.51"><vh>Label.translate</vh></v>
</v>
</v>
<v t="leo.20181129171705.12"><vh>@clean line.py</vh>
<v t="leo.20181129171706.52"><vh>Declarations (line.py)</vh></v>
<v t="leo.20181129171706.53" a="E"><vh>class LineSegment</vh>
<v t="leo.20181129171706.54"><vh>LineSegment.__init__</vh></v>
<v t="leo.20181129171706.55"><vh>LineSegment._buildAsset</vh></v>
<v t="leo.20181129171706.56"><vh>LineSegment.physicalPointTouching</vh></v>
<v t="leo.20181129171706.57"><vh>LineSegment.translate</vh></v>
</v>
</v>
<v t="leo.20181129171705.13"><vh>@clean logic.py</vh>
<v t="leo.20181129171706.58"><vh>Declarations (logic.py)</vh></v>
<v t="leo.20181129171706.59"><vh>_recursiontrap (logic.py)</vh></v>
<v t="leo.20181129171706.60"><vh>class _BoolDevice</vh>
<v t="leo.20181129171706.61"><vh>_BoolDevice.__init__</vh></v>
<v t="leo.20181129171706.62"><vh>_BoolDevice.In</vh></v>
<v t="leo.20181129171706.63"><vh>_BoolDevice.In</vh></v>
<v t="leo.20181129171706.64"><vh>_BoolDevice.Enable</vh></v>
<v t="leo.20181129171706.65"><vh>_BoolDevice.Enable</vh></v>
<v t="leo.20181129171706.66"><vh>_BoolDevice._getvalue</vh></v>
<v t="leo.20181129171706.67"><vh>_BoolDevice._inputState</vh></v>
<v t="leo.20181129171706.68"><vh>_BoolDevice.__call__</vh></v>
<v t="leo.20181129171706.69"><vh>_BoolDevice.GetInput</vh></v>
<v t="leo.20181129171706.70"><vh>_BoolDevice.SetInput</vh></v>
</v>
<v t="leo.20181129171706.71"><vh>class _BoolOneInput</vh>
<v t="leo.20181129171706.72"><vh>_BoolOneInput.__init__</vh></v>
</v>
<v t="leo.20181129171706.73"><vh>class _BoolMultiInput</vh>
<v t="leo.20181129171706.74"><vh>_BoolMultiInput.__init__</vh></v>
</v>
<v t="leo.20181129171706.75"><vh>class BoolNOT</vh>
<v t="leo.20181129171706.76"><vh>BoolNOT._getvalue</vh></v>
</v>
<v t="leo.20181129171706.77"><vh>class BoolAND</vh>
<v t="leo.20181129171706.78"><vh>BoolAND._getvalue</vh></v>
</v>
<v t="leo.20181129171706.79"><vh>class BoolNOR</vh>
<v t="leo.20181129171706.80"><vh>BoolNOR._getvalue</vh></v>
</v>
<v t="leo.20181129171706.81"><vh>class BoolNAND</vh>
<v t="leo.20181129171706.82"><vh>BoolNAND._getvalue</vh></v>
</v>
<v t="leo.20181129171706.83"><vh>class BoolSRFF</vh>
<v t="leo.20181129171706.84"><vh>BoolSRFF.__init__</vh></v>
<v t="leo.20181129171706.85"><vh>BoolSRFF.SetInput</vh></v>
<v t="leo.20181129171706.86"><vh>BoolSRFF._getvalue</vh></v>
<v t="leo.20181129171706.87"><vh>BoolSRFF.Q_</vh></v>
<v t="leo.20181129171706.88"><vh>BoolSRFF.Q</vh></v>
</v>
</v>
<v t="leo.20181129171705.14"><vh>@clean mathapp.py</vh>
<v t="leo.20181129171706.89"><vh>Declarations (mathapp.py)</vh></v>
<v t="leo.20181129171706.90"><vh>class MathApp</vh>
<v t="leo.20181129171706.91"><vh>MathApp.__init__</vh></v>
<v t="leo.20181129171706.92"><vh>MathApp.step</vh></v>
<v t="leo.20181129171706.93"><vh>MathApp._touchAllVisuals</vh></v>
<v t="leo.20181129171706.94"><vh>MathApp.logicalToPhysical</vh></v>
<v t="leo.20181129171706.95"><vh>MathApp.physicalToLogical</vh></v>
<v t="leo.20181129171706.96"><vh>MathApp.translateLogicalToPhysical</vh></v>
<v t="leo.20181129171706.97"><vh>MathApp.translatePhysicalToLogical</vh></v>
<v t="leo.20181129171706.98"><vh>MathApp._handleMouseClick</vh></v>
<v t="leo.20181129171706.99"><vh>MathApp._handleMouseDown</vh></v>
<v t="leo.20181129171706.100"><vh>MathApp._handleMouseUp</vh></v>
<v t="leo.20181129171706.101"><vh>MathApp._handleMouseMove</vh></v>
<v t="leo.20181129171706.102"><vh>MathApp._handleMouseWheel</vh></v>
<v t="leo.20181129171706.103"><vh>MathApp.viewPosition</vh></v>
<v t="leo.20181129171707.1"><vh>MathApp.viewPosition</vh></v>
<v t="leo.20181129171707.2"><vh>MathApp.addViewNotification</vh></v>
<v t="leo.20181129171707.3"><vh>MathApp.removeViewNotification</vh></v>
<v t="leo.20181129171707.4"><vh>MathApp._viewNotify</vh></v>
<v t="leo.20181129171707.5"><vh>MathApp.distance</vh></v>
<v t="leo.20181129171707.6"><vh>MathApp.scale</vh></v>
<v t="leo.20181129171707.7"><vh>MathApp.width</vh></v>
<v t="leo.20181129171707.8"><vh>MathApp.width</vh></v>
<v t="leo.20181129171707.9"><vh>MathApp._addVisual</vh></v>
<v t="leo.20181129171707.10"><vh>MathApp._removeVisual</vh></v>
<v t="leo.20181129171707.11"><vh>MathApp._addDynamic</vh></v>
<v t="leo.20181129171707.12"><vh>MathApp._removeDynamic</vh></v>
<v t="leo.20181129171707.13"><vh>MathApp._addMovable</vh></v>
<v t="leo.20181129171707.14"><vh>MathApp._removeMovable</vh></v>
<v t="leo.20181129171707.15"><vh>MathApp._addSelectable</vh></v>
<v t="leo.20181129171707.16"><vh>MathApp._removeSelectable</vh></v>
<v t="leo.20181129171707.17"><vh>MathApp._addStrokable</vh></v>
<v t="leo.20181129171707.18"><vh>MathApp._removeStrokable</vh></v>
<v t="leo.20181129171707.19"><vh>MathApp._destroy</vh></v>
</v>
<v t="leo.20181129171707.20"><vh>class _MathDynamic</vh>
<v t="leo.20181129171707.21"><vh>_MathDynamic.__init__</vh></v>
<v t="leo.20181129171707.22"><vh>_MathDynamic.destroy</vh></v>
<v t="leo.20181129171707.23"><vh>_MathDynamic.step</vh></v>
<v t="leo.20181129171707.24"><vh>_MathDynamic.Eval</vh></v>
<v t="leo.20181129171707.25"><vh>_MathDynamic._setDynamic</vh></v>
</v>
<v t="leo.20181129171707.26" a="E"><vh>class _MathVisual</vh>
<v t="leo.20181129171707.27"><vh>_MathVisual.__init__</vh></v>
<v t="leo.20181129171707.28"><vh>_MathVisual.step</vh></v>
<v t="leo.20181129171707.29"><vh>_MathVisual._saveInputs</vh></v>
<v t="leo.20181129171707.30"><vh>_MathVisual._getInputs</vh></v>
<v t="leo.20181129171707.31"><vh>_MathVisual._getPhysicalInputs</vh></v>
<v t="leo.20181129171707.32"><vh>_MathVisual._inputsChanged</vh></v>
<v t="leo.20181129171707.33"><vh>_MathVisual.destroy</vh></v>
<v t="leo.20181129171707.34"><vh>_MathVisual._updateAsset</vh></v>
<v t="leo.20181129171707.35"><vh>_MathVisual.positioning</vh></v>
<v t="leo.20181129171707.36"><vh>_MathVisual.positioning</vh></v>
<v t="leo.20181129171707.37"><vh>_MathVisual.movable</vh></v>
<v t="leo.20181129171707.38"><vh>_MathVisual.movable</vh></v>
<v t="leo.20181129171707.39"><vh>_MathVisual.selectable</vh></v>
<v t="leo.20181129171707.40"><vh>_MathVisual.selectable</vh></v>
<v t="leo.20181129171707.41"><vh>_MathVisual.strokable</vh></v>
<v t="leo.20181129171707.42"><vh>_MathVisual.strokable</vh></v>
<v t="leo.20181129171707.43"><vh>_MathVisual.select</vh></v>
<v t="leo.20181129171707.44"><vh>_MathVisual.unselect</vh></v>
<v t="leo.20181129171707.45"><vh>_MathVisual.mousedown</vh></v>
<v t="leo.20181129171707.46"><vh>_MathVisual.mouseup</vh></v>
<v t="leo.20181129171707.47"><vh>_MathVisual.processEvent</vh></v>
<v t="leo.20181129171707.48"><vh>_MathVisual.physicalPointTouching</vh></v>
<v t="leo.20181129171707.49"><vh>_MathVisual.translate</vh></v>
<v t="leo.20181129171707.50"><vh>_MathVisual.stroke</vh></v>
<v t="leo.20181129171707.51"><vh>_MathVisual.canStroke</vh></v>
<v t="leo.20181129171707.52"><vh>_MathVisual._touchAsset</vh></v>
<v t="leo.20181129171707.53"><vh>_MathVisual._buildAsset</vh></v>
</v>
</v>
<v t="leo.20181129171705.15"><vh>@clean mathbase.py</vh>
<v t="leo.20181129171707.54"><vh>Declarations (mathbase.py)</vh></v>
<v t="leo.20181129171707.55"><vh>class _MathDynamic</vh>
<v t="leo.20181129171707.56"><vh>_MathDynamic.__init__</vh></v>
<v t="leo.20181129171707.57"><vh>_MathDynamic.destroy</vh></v>
<v t="leo.20181129171707.58"><vh>_MathDynamic.step</vh></v>
<v t="leo.20181129171707.59"><vh>_MathDynamic.Eval</vh></v>
<v t="leo.20181129171707.60"><vh>_MathDynamic._setDynamic</vh></v>
</v>
<v t="leo.20181129171707.61"><vh>class _MathVisual</vh>
<v t="leo.20181129171707.62"><vh>_MathVisual.__init__</vh></v>
<v t="leo.20181129171707.63"><vh>_MathVisual.step</vh></v>
<v t="leo.20181129171707.64"><vh>_MathVisual._saveInputs</vh></v>
<v t="leo.20181129171707.65"><vh>_MathVisual._getInputs</vh></v>
<v t="leo.20181129171707.66"><vh>_MathVisual._getPhysicalInputs</vh></v>
<v t="leo.20181129171707.67"><vh>_MathVisual._inputsChanged</vh></v>
<v t="leo.20181129171707.68"><vh>_MathVisual.destroy</vh></v>
<v t="leo.20181129171707.69"><vh>_MathVisual._updateAsset</vh></v>
<v t="leo.20181129171707.70"><vh>_MathVisual.movable</vh></v>
<v t="leo.20181129171707.71"><vh>_MathVisual.movable</vh></v>
<v t="leo.20181129171707.72"><vh>_MathVisual.selectable</vh></v>
<v t="leo.20181129171707.73"><vh>_MathVisual.selectable</vh></v>
<v t="leo.20181129171707.74"><vh>_MathVisual.strokable</vh></v>
<v t="leo.20181129171707.75"><vh>_MathVisual.strokable</vh></v>
<v t="leo.20181129171707.76"><vh>_MathVisual.select</vh></v>
<v t="leo.20181129171707.77"><vh>_MathVisual.unselect</vh></v>
<v t="leo.20181129171707.78"><vh>_MathVisual.mousedown</vh></v>
<v t="leo.20181129171707.79"><vh>_MathVisual.mouseup</vh></v>
<v t="leo.20181129171707.80"><vh>_MathVisual.processEvent</vh></v>
<v t="leo.20181129171707.81"><vh>_MathVisual.physicalPointTouching</vh></v>
<v t="leo.20181129171707.82"><vh>_MathVisual.translate</vh></v>
<v t="leo.20181129171707.83"><vh>_MathVisual.stroke</vh></v>
<v t="leo.20181129171707.84"><vh>_MathVisual.canstroke</vh></v>
<v t="leo.20181129171707.85"><vh>_MathVisual._touchAsset</vh></v>
<v t="leo.20181129171707.86"><vh>_MathVisual._buildAsset</vh></v>
</v>
</v>
<v t="leo.20181129171705.16"><vh>@clean point.py</vh>
<v t="leo.20181129171707.87"><vh>Declarations (point.py)</vh></v>
<v t="leo.20181129171707.88"><vh>class _Point</vh>
<v t="leo.20181129171707.89"><vh>_Point.__init__</vh></v>
<v t="leo.20181129171707.90"><vh>_Point.__call__</vh></v>
<v t="leo.20181129171707.91"><vh>_Point.step</vh></v>
<v t="leo.20181129171707.92"><vh>_Point.physicalPointTouching</vh></v>
<v t="leo.20181129171707.93"><vh>_Point.translate</vh></v>
<v t="leo.20181129171707.94"><vh>_Point.distanceTo</vh></v>
</v>
<v t="leo.20181129171707.95" a="E"><vh>class Point</vh>
<v t="leo.20181129171707.96"><vh>Point.__init__</vh></v>
<v t="leo.20181129171707.97"><vh>Point._buildAsset</vh></v>
</v>
<v t="leo.20181129171707.98"><vh>class ImagePoint</vh>
<v t="leo.20181129171707.99"><vh>ImagePoint.__init__</vh></v>
<v t="leo.20181129171707.100"><vh>ImagePoint._buildAsset</vh></v>
<v t="leo.20181129171707.101"><vh>ImagePoint.physicalPointTouching</vh></v>
</v>
</v>
<v t="leo.20181129171705.17"><vh>@clean pygamedeps.py</vh>
<v t="leo.20181129171707.102"><vh>module_exists (pygamedeps.py)</vh></v>
</v>
<v t="leo.20181129171705.18"><vh>@clean slider.py</vh>
<v t="leo.20181129171707.103"><vh>Declarations (slider.py)</vh></v>
<v t="leo.20181129171707.104" a="E"><vh>class Slider</vh>
<v t="leo.20181129171707.105"><vh>Slider.__init__</vh></v>
<v t="leo.20181129171707.106"><vh>Slider._thumbXY</vh></v>
<v t="leo.20181129171707.107"><vh>Slider.__call__</vh></v>
<v t="leo.20181129171707.108"><vh>Slider.value</vh></v>
<v t="leo.20181129171707.109"><vh>Slider.value</vh></v>
<v t="leo.20181129171707.110"><vh>Slider._buildAsset</vh></v>
<v t="leo.20181129171707.111"><vh>Slider._setThumb</vh></v>
<v t="leo.20181129171707.112"><vh>Slider.step</vh></v>
<v t="leo.20181129171707.113"><vh>Slider._setval</vh></v>
<v t="leo.20181129171707.114"><vh>Slider.increment</vh></v>
<v t="leo.20181129171707.115"><vh>Slider.select</vh></v>
<v t="leo.20181129171707.116"><vh>Slider.unselect</vh></v>
<v t="leo.20181129171707.117"><vh>Slider._mouseClick</vh></v>
<v t="leo.20181129171707.118"><vh>Slider._moveLeft</vh></v>
<v t="leo.20181129171707.119"><vh>Slider._moveRight</vh></v>
<v t="leo.20181129171707.120"><vh>Slider._moveCenter</vh></v>
<v t="leo.20181129171707.121"><vh>Slider.canstroke</vh></v>
<v t="leo.20181129171707.122"><vh>Slider.stroke</vh></v>
<v t="leo.20181129171707.123"><vh>Slider.physicalPointTouching</vh></v>
<v t="leo.20181129171707.124"><vh>Slider.physicalPointTouchingThumb</vh></v>
<v t="leo.20181129171707.125"><vh>Slider.translate</vh></v>
<v t="leo.20181129171707.126"><vh>Slider.destroy</vh></v>
</v>
</v>
<v t="leo.20181129171705.19"><vh>@clean sound.py</vh>
<v t="leo.20181129171707.127"><vh>Declarations (sound.py)</vh></v>
<v t="leo.20181129171707.128"><vh>class SoundAsset</vh>
<v t="leo.20181129171707.129"><vh>SoundAsset.__init__</vh></v>
</v>
<v t="leo.20181129171707.130"><vh>class Sound</vh>
<v t="leo.20181129171707.131"><vh>Sound.__init__</vh></v>
<v t="leo.20181129171707.132"><vh>Sound.play</vh></v>
<v t="leo.20181129171707.133"><vh>Sound.loop</vh></v>
<v t="leo.20181129171707.134"><vh>Sound.stop</vh></v>
<v t="leo.20181129171707.135"><vh>Sound.volume</vh></v>
<v t="leo.20181129171707.136"><vh>Sound.volume</vh></v>
</v>
</v>
<v t="leo.20181129171705.20"><vh>@clean sprite.py</vh>
<v t="leo.20181129171707.137"><vh>Declarations (sprite.py)</vh></v>
<v t="leo.20181129171707.138" a="E"><vh>class Sprite</vh>
<v t="leo.20181129171707.139"><vh>Sprite.__init__</vh></v>
<v t="leo.20181129171707.140"><vh>Sprite._createBaseVertices</vh></v>
<v t="leo.20181129171707.141"><vh>Sprite._xformVertices</vh></v>
<v t="leo.20181129171707.142"><vh>Sprite._setExtents</vh></v>
<v t="leo.20181129171707.143"><vh>Sprite.firstImage</vh></v>
<v t="leo.20181129171707.144"><vh>Sprite.lastImage</vh></v>
<v t="leo.20181129171707.145"><vh>Sprite.nextImage</vh></v>
<v t="leo.20181129171707.146"><vh>Sprite.prevImage</vh></v>
<v t="leo.20181129171707.147"><vh>Sprite.setImage</vh></v>
<v t="leo.20181129171707.148"><vh>Sprite.rectangularCollisionModel</vh></v>
<v t="leo.20181129171707.149"><vh>Sprite.circularCollisionModel</vh></v>
<v t="leo.20181129171707.150"><vh>Sprite.index</vh></v>
<v t="leo.20181129171707.151"><vh>Sprite.index</vh></v>
<v t="leo.20181129171707.152"><vh>Sprite.width</vh></v>
<v t="leo.20181129171707.153"><vh>Sprite.width</vh></v>
<v t="leo.20181129171707.154"><vh>Sprite.height</vh></v>
<v t="leo.20181129171707.155"><vh>Sprite.height</vh></v>
<v t="leo.20181129171707.156"><vh>Sprite.x</vh></v>
<v t="leo.20181129171707.157"><vh>Sprite.x</vh></v>
<v t="leo.20181129171707.158"><vh>Sprite.y</vh></v>
<v t="leo.20181129171707.159"><vh>Sprite.y</vh></v>
<v t="leo.20181129171707.160"><vh>Sprite.position</vh></v>
<v t="leo.20181129171707.161"><vh>Sprite.position</vh></v>
<v t="leo.20181129171707.162"><vh>Sprite.fxcenter</vh></v>
<v t="leo.20181129171707.163"><vh>Sprite.fxcenter</vh></v>
<v t="leo.20181129171707.164"><vh>Sprite.fycenter</vh></v>
<v t="leo.20181129171707.165"><vh>Sprite.fycenter</vh></v>
<v t="leo.20181129171707.166"><vh>Sprite.center</vh></v>
<v t="leo.20181129171707.167"><vh>Sprite.center</vh></v>
<v t="leo.20181129171707.168"><vh>Sprite.visible</vh></v>
<v t="leo.20181129171707.169"><vh>Sprite.visible</vh></v>
<v t="leo.20181129171707.170"><vh>Sprite.scale</vh></v>
<v t="leo.20181129171707.171"><vh>Sprite.scale</vh></v>
<v t="leo.20181129171707.172"><vh>Sprite.rotation</vh></v>
<v t="leo.20181129171707.173"><vh>Sprite.rotation</vh></v>
<v t="leo.20181129171707.174"><vh>Sprite.collidingCircleWithPoly</vh></v>
<v t="leo.20181129171707.175"><vh>Sprite.collidingPolyWithPoly</vh></v>
<v t="leo.20181129171707.176"><vh>Sprite.collidingWith</vh></v>
<v t="leo.20181129171707.177"><vh>Sprite.collidingWithSprites</vh></v>
<v t="leo.20181129171707.178"><vh>Sprite.destroy</vh></v>
</v>
</v>
<v t="leo.20181129171705.21"><vh>@clean sysdeps.py</vh>
<v t="leo.20181129171707.179"><vh>module_exists (sysdeps.py)</vh></v>
</v>
<v t="leo.20181129171705.22"><vh>@clean timer.py</vh>
<v t="leo.20181129171708.1"><vh>Declarations (timer.py)</vh></v>
<v t="leo.20181129171708.2" a="E"><vh>class Timer</vh>
<v t="leo.20181129171708.3"><vh>Timer.__init__</vh></v>
<v t="leo.20181129171708.4"><vh>Timer.reset</vh></v>
<v t="leo.20181129171708.5"><vh>Timer.step</vh></v>
<v t="leo.20181129171708.6"><vh>Timer.callAfter</vh></v>
<v t="leo.20181129171708.7"><vh>Timer.callAt</vh></v>
<v t="leo.20181129171708.8"><vh>Timer.callEvery</vh></v>
<v t="leo.20181129171708.9"><vh>Timer.__call__</vh></v>
</v>
</v>
</v>
<v t="leo.20181129163357.1"><vh>@settings</vh>
<v t="leo.20181129163357.2"><vh>@data qt-gui-plugin-style-sheet</vh></v>
<v t="leo.20181129163357.3"><vh>@string initial_split_orientation = horizontal</vh></v>
</v>
<v t="leo.20181129164549.1"><vh>有關 kmolgame</vh>
<v t="leo.20181130105336.1"><vh>更新 ggame 2018.11.30</vh></v>
</v>
<v t="leo.20181130073250.1" a="E"><vh>最簡單的 Ggame 範例</vh>
<v t="leo.20181130073306.1" a="E"><vh>@clean simple1.html</vh>
<v t="leo.20181130073306.2"><vh>&lt;&lt;game_title&gt;&gt;</vh></v>
<v t="leo.20181130073306.3"><vh>game body</vh></v>
</v>
</v>
<v t="leo.20181130214116.1"><vh>@clean conway.html</vh>
<v t="leo.20181130214116.2"><vh>&lt;&lt;game_title&gt;&gt;</vh></v>
<v t="leo.20181130214116.3"><vh>game body</vh></v>
</v>
<v t="leo.20181203150038.1" a="E"><vh>@clean no.1.html</vh>
<v t="leo.20181203150038.2"><vh>&lt;&lt;game_title&gt;&gt;</vh></v>
<v t="leo.20181203150038.3"><vh>game body</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="leo.20181129163357.1"></t>
<t tx="leo.20181129163357.2">QSplitter::handle {
    background-color: #CAE1FF; /* lightSteelBlue1 */
}

QStackedWidget {
    /* background-color:lightpink; */
    border-color: red;
    padding: 0px;
    /* border-width: 0px; */
    /* background-color: yellow; */
}

QSplitter {
    border-color: white;
    background-color: white;
    border-style: solid;
}

QTreeWidget {
    /* These apply to the selected item, but not to editing items.*/
    background-color: #ffffec; /* Leo's traditional tree color */
    selection-color: black; /* was white */
    selection-background-color: lightgrey;
    /* font-family: SansSerif; */
    /*font-family: DejaVu Sans Mono;*/
    font-family:YaHei Mono;
    /* 標題字型大小設定 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
 }

/* Headline edit widgets */
QTreeWidget QLineEdit {
    background-color: cornsilk;
    selection-color: white;
    selection-background-color: blue;
    /*font-family: DejaVu Sans Mono;*/    
    font-family:YaHei Mono;
    /* 沒有特別對應字型大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The log panes */
QTextEdit {
    background-color: #f2fdff;
    selection-color: red;
    selection-background-color: blue;
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* log font 大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal, italic,oblique */
}

/* The body pane */
QTextEdit#richTextEdit {
    background-color: #fdf5f5; /* A kind of pink. */
    selection-color: white;
    selection-background-color: red;
    /*font-family: DejaVu Sans Mono;*/
    /* font-family: Courier New; */
    font-family:YaHei Mono;
    /* 內文字型大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

QLabel {
    font-family:YaHei Mono;
    /* 下方的 Minibuffer 標題字型大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
}

/* Editor labels */
QLineEdit#editorLabel {
    background-color: #ffffec;
    font-family:YaHei Mono;
    /* 沒有直接對應字型大小 */
    font-size: 22px;
    font-weight: normal; /* normal,bold,100,..,900 */
    font-style: normal; /* normal,italic,oblique */
    border: 2px;
    margin: 2px;
}</t>
<t tx="leo.20181129163357.3">horizontal: body pane to the left
vertical: body pane on the botton</t>
<t tx="leo.20181129163546.1">@language html
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;&lt;game_title&gt;&gt;
&lt;link rel="shortcut icon" href="css/favicon.ico"&gt;    
&lt;link rel="stylesheet" type="text/css" href="css/bssite.css" media="screen" /&gt;
 
&lt;script type="text/javascript" src="static/jquery-3.3.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/jquery-ui.1.12.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/pixi-4.8.2.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/buzz-1.2.1.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython-3.7.0.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython_stdlib-3.7.0.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="text/javascript"&gt;
window.onload=function(){
brython({debug:1, pythonpath:['static']});
}
&lt;/script&gt;
&lt;script type="text/python"&gt;
@others
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</t>
<t tx="leo.20181129163716.1">@language python
# 導入模組
from ggame import App, ImageAsset, Sprite, MouseEvent
from random import random, randint

class Bunny(Sprite):
    
    asset = ImageAsset("images/bunny.png")
    
    def __init__(self, position):
        super().__init__(Bunny.asset, position)
        # register mouse events
        App.listenMouseEvent(MouseEvent.mousedown, self.mousedown)
        App.listenMouseEvent(MouseEvent.mouseup, self.mouseup)
        App.listenMouseEvent(MouseEvent.mousemove, self.mousemove)
        self.dragging = False

    
    def step(self):
        """
        Every now and then a bunny hops...
        """
        if random() &lt; 0.01:
            self.x += randint(-20,20)
            self.y += randint(-20,20)
        
        
    def mousedown(self, event):
        # capture any mouse down within 50 pixels
        self.deltax = event.x - (self.x + self.width//2) 
        self.deltay = event.y - (self.y + self.height//2)
        if abs(self.deltax) &lt; 50 and abs(self.deltay) &lt; 50:
            self.dragging = True
            # only drag one bunny at a time - consume the event
            event.consumed = True
            
    def mousemove(self, event):
        if self.dragging:
            self.x = event.x - self.deltax - self.width//2
            self.y = event.y - self.deltay - self.height//2
            event.consumed = True
            
    def mouseup(self, event):
        if self.dragging:
            self.dragging = False
            event.consumed = True
            
        
class DemoApp(App):
    
    def __init__(self):
        super().__init__()
        for i in range(10):
            Bunny((randint(50,self.width),randint(50,self.height)))
        
    def step(self):
        """
        Override step to perform action on each frame update
        """
        for bunny in self.spritelist:
            bunny.step()


# Create the app
app = DemoApp()  
# Run the app
app.run()

</t>
<t tx="leo.20181129164111.1">@language python
import os
import subprocess
import threading
import http.server, ssl

def domake():
    # build directory
    #os.chdir("./../")
    server_address = ('localhost', 8444)
    httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler)
    httpd.socket = ssl.wrap_socket(httpd.socket,
                                   server_side=True,
                                   certfile='localhost.crt',
                                   keyfile='localhost.key',
                                   ssl_version=ssl.PROTOCOL_TLSv1)
    print(os.getcwd())
    print("8444 https server started")
    httpd.serve_forever()

# 利用執行緒執行 https 伺服器
make = threading.Thread(target=domake)
make.start()</t>
<t tx="leo.20181129164322.1">&lt;title&gt;Game1&lt;/title&gt;

</t>
<t tx="leo.20181129164549.1">kmolgame 是一套以 brython 與 pixi 程式庫為主的網際程式庫
以下使用 clone node clean</t>
<t tx="leo.20181129165714.1">@language html
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;&lt;game_title&gt;&gt;
&lt;link rel="shortcut icon" href="css/favicon.ico"&gt;    
&lt;link rel="stylesheet" type="text/css" href="css/bssite.css" media="screen" /&gt;
 
&lt;script type="text/javascript" src="static/jquery-3.3.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/jquery-ui.1.12.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/pixi-4.8.2.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/buzz-1.2.1.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython-3.7.0.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython_stdlib-3.7.0.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="text/javascript"&gt;
window.onload=function(){
brython({debug:1, pythonpath:['static']});
}
&lt;/script&gt;
&lt;script type="text/python"&gt;
@others
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</t>
<t tx="leo.20181129165714.2">&lt;title&gt;太空大戰&lt;/title&gt;

</t>
<t tx="leo.20181129165714.3">@language python
# 導入所需模組
from ggame import App, Sprite, ImageAsset, Frame
from ggame import SoundAsset, Sound, TextAsset, Color
import math
from time import time

# 建立 Stars 類別, 繼承 Sprite 物件
class Stars(Sprite):

    asset = ImageAsset("images/starfield.jpg")
    width = 512
    height = 512

    def __init__(self, position):
        super().__init__(Stars.asset, position)

class Sun(Sprite):

    asset = ImageAsset("images/sun.png")
    width = 80
    height = 76
    
    def __init__(self, position):
        super().__init__(Sun.asset, position)
        self.mass = 30*1000
        self.fxcenter = 0.5
        self.fycenter = 0.5
        self.circularCollisionModel()

class Vector:

    def __init__(self, x, y):
        self.x = x
        self.y = y

    def mag(self):
        return math.sqrt(self.x*self.x + self.y*self.y)

    def unit(self):
        r = self.mag()
        if r == 0:
            return Vector(0,0)
        else:
            return Vector(self.x/r, self.y/r)

class GravitySprite(Sprite):
    
    G = 50.0

    def __init__(self, asset, position, velocity, sun):
        super().__init__(asset, position)
        self.vx = velocity[0]
        self.vy = velocity[1]
        self.sun = sun
        self.fxcenter = 0.5
        self.fycenter = 0.5
        self.rrate = 0.0
        self.thrust = 0.0
        self.mass = 1.0
        
    def step(self, T, dT):
        #dt = 0.033
        R = Vector(self.sun.x-self.x, self.sun.y-self.y)
        #Ur = R.unit()
        r = R.mag()
        Ux, Uy = R.x/r, R.y/r
        ag = GravitySprite.G*self.sun.mass/R.mag()**2
        Agx, Agy = Ux*ag, Uy*ag
        vx, vy = self.vx, self.vy
        At = self.thrust/self.mass
        dt2o2 = dT*dT*0.5
        self.vx = self.vx + (Agx - At*math.sin(self.rotation))* dT
        self.vy = self.vy + (Agy - At*math.cos(self.rotation))* dT
        self.x = self.x + self.vx * dT + Agx*dt2o2
        self.y = self.y + self.vy * dT + Agy*dt2o2


class Bullet(GravitySprite):
    
    asset = ImageAsset("images/blast.png", Frame(0,0,8,8), 8)
    pewasset = SoundAsset("sounds/pew1.mp3")
    
    def __init__(self, app, sun):
        super().__init__(Bullet.asset, (0,0), (0,0), sun)
        self.visible = False
        self.firing = False
        self.time = 0
        self.circularCollisionModel()
        self.pew = Sound(Bullet.pewasset)
        self.pew.volume = 10
        
    def shoot(self, position, velocity, time):
        self.position = position
        self.vx = velocity[0]
        self.vy = velocity[1]
        self.time = time
        self.visible = True
        self.firing = True
        self.pew.play()

    def step(self, T, dT):
        if self.time &gt; 0:
            self.time = self.time - dT
            if self.visible:
                self.nextImage(True)
                super().step(T, dT)
                if self.collidingWith(self.sun):
                    self.visible = False
                    ExplosionSmall(self.position)
                ships = []
                ships = self.collidingWithSprites(Ship1)
                ships.extend(self.collidingWithSprites(Ship2))
                if len(ships):
                    if not self.firing and ships[0].visible:
                        ships[0].explode()
                        self.visible = False
                elif self.firing:
                    self.firing = False
            
                
        else:
            if self.visible:
                self.visible = False
            self.time = 0


class HealthBar:

    def __init__(self, indicatorasset, initvalue, position, app):
        self.sprites = [Sprite(indicatorasset, (0,app.height-75)) for i in range(initvalue)]
        for s in self.sprites:
            s.scale = 0.4
        width = self.sprites[0].width
        if position == 'left':
            x = 50
            step = width+5
        else:
            x = app.width - 50 - width
            step = -width-5
        for s in self.sprites:
            s.x = x
            x = x + step
        self.restart()
        
    def restart(self):
        for s in self.sprites:
            s.visible = True
        self.count = len(self.sprites)
        
    def dead(self):
        return self.count == 0
        
    def killone(self):
        if self.count &gt; 0:
            self.count =  self.count - 1
            self.sprites[self.count].visible = False


class Ship(GravitySprite):

    R = 2.0
    bullets = 6
    healthcount = 6
    reappearasset = SoundAsset("sounds/reappear.mp3")
    
    def __init__(self, asset, app, position, velocity, sun):
        self.bullets = []
        for i in range(Ship.bullets):
            self.bullets.append(Bullet(app, sun))
        super().__init__(asset, position, velocity, sun)
        self.initposition = position
        self.initvelocity = self.vx, self.vy
        self.initrotation = self.rotation
        self.app = app
        self.mass = 1.0
        self.circularCollisionModel()
        self.imagex = 0
        self.reappear = Sound(Ship.reappearasset)
        self.reappear.volume = 40
        self.waitspawn = 0
        self.respawnplayed = False
        healthpos = 'left' if position[0] &lt; app.width/2 else 'right'
        self.health = HealthBar(asset, Ship.healthcount, healthpos, app)
        self.dead = False

    def registerKeys(self, keys):
        commands = ["left", "right", "forward", "fire"]
        self.keymap = dict(zip(keys, commands))
        [self.app.listenKeyEvent("keydown", k, self.controldown) for k in keys]
        [self.app.listenKeyEvent("keyup", k, self.controlup) for k in keys]

    def shootvector(self):
        vel = 150
        xv = vel*(-math.sin(self.rotation))
        yv = vel*(-math.cos(self.rotation))
        return xv + self.vx, yv + self.vy
        

    def controldown(self, event):
        if self.visible:
            command = self.keymap[event.key]
            if command == "left":
                self.rrate = Ship.R
            elif command == "right":
                self.rrate = -Ship.R
            elif command == "forward":
                self.thrust = 40.0
                self.imagex = 1 # start the animated rockets
                self.setImage(self.imagex)
            elif command == "fire":
                for bullet in self.bullets:
                    if bullet.time == 0:
                        bullet.shoot(self.position, self.shootvector(), 10)
                        break
                        
            
    def controlup(self, event):
        command = self.keymap[event.key]
        if command in ["left", "right"]:
            self.rrate = 0.0
        elif command == "forward":
            self.thrust = 0.0
            self.imagex = 0 # stop the animated rockets
            self.setImage(self.imagex)
            
    def step(self, T, dT):
        if self.waitspawn &gt; 0:
            self.waitspawn = self.waitspawn - dT
            if self.waitspawn &lt; 1 and not self.respawnplayed:
                self.reappear.play()
                self.respawnplayed = True
            if self.waitspawn &lt;= 0:
                self.reset()
        for bullet in self.bullets:
            bullet.step(T, dT)
        if self.visible:
            super().step(T, dT)
            self.rotation = self.rotation + self.rrate * dT
            if self.collidingWith(self.sun):
                self.explode()
            if self.thrust != 0.0:
                self.imagex = self.imagex + 1    # animate the rockets
                if self.imagex == 4:
                    self.imagex = 1
                self.setImage(self.imagex)
            if (self.x &lt; -100 or self.x &gt; self.app.width + 100 or
                self.y &lt; -100 or self.y &gt; self.app.height + 100):
                self.explode()
        

    def explode(self):
        self.visible = False
        ExplosionBig(self.position)
        self.waitspawn = 5

    def reset(self):
        if not self.health.dead():
            self.position = self.initposition
            self.vx, self.vy = self.initvelocity
            self.rotation = self.initrotation
            self.visible = True
            self.respawnplayed = False
            self.health.killone()
        else:
            self.dead = True

    def newgame(self):
        self.health.restart()
        self.dead = False
        self.reset()

class Ship1(Ship):

    asset = ImageAsset("images/four_spaceship_by_albertov_with_thrust.png", 
        Frame(227,0,292-227,125), 4, 'vertical')

    def __init__(self, app, position, velocity, sun):
        super().__init__(Ship1.asset, app, position, velocity, sun)
        self.registerKeys(["a", "d", "w", "space"])
        
    def step(self, T, dT):
        super().step(T, dT)
        if self.visible:
            collides = self.collidingWithSprites(Ship2)
            if len(collides):
                if collides[0].visible:
                    collides[0].explode()
                    self.explode()
        
class Ship2(Ship):
    
    asset = ImageAsset("images/four_spaceship_by_albertov_with_thrust.png", 
        Frame(0,0,86,125), 4, 'vertical')
        
    def __init__(self, app, position, velocity, sun):
        super().__init__(Ship2.asset, app, position, velocity, sun)
        self.registerKeys(["left arrow", "right arrow", "up arrow", "enter"])

    def step(self, T, dT):
        super().step(T, dT)
        if self.visible:
            collides = self.collidingWithSprites(Ship1)
            if len(collides):
                if collides[0].visible:
                    collides[0].explode()
                    self.explode()

class ExplosionSmall(Sprite):
    
    asset = ImageAsset("images/explosion1.png", Frame(0,0,128,128), 10)
    boomasset = SoundAsset("sounds/explosion1.mp3")
    
    def __init__(self, position):
        super().__init__(ExplosionSmall.asset, position)
        self.image = 0
        self.center = (0.5, 0.5)
        self.boom = Sound(ExplosionSmall.boomasset)
        self.boom.play()
        
    def step(self):
        self.setImage(self.image//2)  # slow it down
        self.image = self.image + 1
        if self.image == 20:
            self.destroy()

class ExplosionBig(Sprite):
    
    asset = ImageAsset("images/explosion2.png", Frame(0,0,4800/25,195), 25)
    boomasset = SoundAsset("sounds/explosion2.mp3")
    
    def __init__(self, position):
        super().__init__(ExplosionBig.asset, position)
        self.image = 0
        self.center = (0.5, 0.5)
        self.boom = Sound(ExplosionBig.boomasset)
        self.boom.play()
        
    def step(self):
        self.setImage(self.image//2)  # slow it down
        self.image = self.image + 1
        if self.image == 50:
            self.destroy()

class Spacewar(App):
    
    strings = {'winner': 'WINNER!',
        'tie': 'TIE!',
        'space': 'Press SPACE to play.',
        'left': 'AWD\nSpace to FIRE',
        'right': 'Arrow Keys\nEnter to FIRE',
        }

    def __init__(self):
        super().__init__()
        for x in range(self.width//Stars.width + 1):
            for y in range(self.height//Stars.height + 1):
                Stars((x*Stars.width, y*Stars.height))
        self.sun = Sun((self.width/2, self.height/2))
        self.ship1 = Ship1(self, (self.width/2-140,self.height/2), (0,-120), self.sun)
        self.ship2 = Ship2(self, (self.width/2+140,self.height/2), (0,120), self.sun)
        self.tsprites = {k:Sprite(TextAsset(text=v, width=200, align='center',style='20px Arial', fill=Color(0xff2222,1))) 
            for k, v in Spacewar.strings.items()}
        self.tsprites['winner'].visible = False
        self.tsprites['winner'].y = self.height/2
        self.tsprites['tie'].visible = False
        self.tsprites['tie'].position = (self.width/2 - 100, self.height/2 + 50)
        self.tsprites['space'].position = (self.width/2 - 100, self.height*3/4)
        self.tsprites['left'].position = (self.width/4 - 50, self.height/2)
        self.tsprites['right'].position = (self.width*3/4 - 50, self.height/2)
        self.state = 'instructions'
        self.listenKeyEvent('keydown', 'space', self.space)

    def space(self, evt):
        if self.state in ['instructions', 'gameover']:
            for t in self.tsprites.values():
                t.visible = False
            self.state = 'playing'
            self.Tlast = time()
            evt.consumed = True
            self.ship1.newgame()
            self.ship2.newgame()

        
    def step(self):
        explosions = self.getSpritesbyClass(ExplosionSmall)
        for explosion in explosions:
            explosion.step()
        explosions = self.getSpritesbyClass(ExplosionBig)
        for explosion in explosions:
            explosion.step()
        if self.state == 'instructions':
            self.tsprites['space'].visible = True
            self.tsprites['left'].visible = True
            self.tsprites['right'].visible = True
        elif self.state == 'playing':
            T = time()
            dT = T-self.Tlast
            self.Tlast = T
            self.ship1.step(T, dT)
            self.ship2.step(T, dT)
            if self.ship1.dead or self.ship2.dead:
                self.state = 'gameover'
        elif self.state == 'gameover':
            self.tsprites['space'].visible = True
            if self.ship1.dead and self.ship2.dead:
                self.tsprites['tie'].visible = True
            else:
                self.tsprites['winner'].visible = True
                self.tsprites['winner'].x = self.width*3/4-50 if self.ship1.dead else self.width/4-50

app = Spacewar()
app.run()

</t>
<t tx="leo.20181129171546.1"></t>
<t tx="leo.20181129171705.10">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.100">def getheading(self):
    """
    User override function for dynamically determining the heading.
    """
    return self.localheading
    
# override or define externally!
</t>
<t tx="leo.20181129171705.101">def gettimezoom(self):
    """
    User override function for dynamically determining the timezoom.
    """
    return 0

# add a status reporting function to status display
</t>
<t tx="leo.20181129171705.102">def addStatusReport(self, statuslist, statusfuncs, statusselect):
    """
    Accept list of all status names, all status text functions, and
    the list of status names that have been selected for display.
    """
    statusdict = {n:f for n, f in zip(statuslist, statusfuncs)}
    for name in statusselect:
        if name in statusdict:
            self._labels.append(
                Label(
                    self.statuspos[:], 
                    statusdict[name], 
                    size=15, 
                    positioning='physical', 
                    width=250))
            self.statuspos[1] += 25

# functions available for reporting flight parameters to UI
</t>
<t tx="leo.20181129171705.103">def velocityText(self):
    """
    Report the velocity in m/s as a text string.
    """
    return "Velocity:     {0:8.1f} m/s".format(self.velocity)
    
</t>
<t tx="leo.20181129171705.104">def accelerationText(self):
    """
    Report the acceleration in m/s as a text string.
    """
    return "Acceleration: {0:8.1f} m/s²".format(self.acceleration)
    
</t>
<t tx="leo.20181129171705.105">def courseDegreesText(self):
    """
    Report the heading in degrees (zero to the right) as a text string.
    """
    return "Course:       {0:8.1f}°".format(degrees(atan2(self.V[1], self.V[0])))

</t>
<t tx="leo.20181129171705.106">def thrustText(self):
    """
    Report the thrust level in Newtons as a text string.
    """
    return "Thrust:       {0:8.1f} N".format(self.thrust())
    
</t>
<t tx="leo.20181129171705.107">def massText(self):
    """
    Report the spacecraft mass in kilograms as a text string.
    """
    return "Mass:         {0:8.1f} kg".format(self.mass())
    
</t>
<t tx="leo.20181129171705.108">def trueAnomalyDegreesText(self):
    """
    Report the true anomaly in degrees as a text string.
    """
    return "True Anomaly: {0:8.1f}°".format(self.tanomalyd)
    
</t>
<t tx="leo.20181129171705.109">def trueAnomalyRadiansText(self):
    """
    Report the true anomaly in radians as a text string.
    """
    return "True Anomaly: {0:8.4f}".format(self.tanomaly)
    
</t>
<t tx="leo.20181129171705.11">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.110">def altitudeText(self):
    """
    Report the altitude in meters as a text string.
    """
    return "Altitude:     {0:8.1f} m".format(self.altitude)
    
</t>
<t tx="leo.20181129171705.111">def radiusText(self):
    """
    Report the radius (distance to planet center) in meters as a text string.
    """
    return "Radius:       {0:8.1f} m".format(self.r)
    
</t>
<t tx="leo.20181129171705.112">def scaleText(self):
    """
    Report the view scale (pixels/meter) as a text string.
    """
    return "View Scale:   {0:8.6f} px/m".format(self.planet.scale)

</t>
<t tx="leo.20181129171705.113">def timeZoomText(self):
    """
    Report the time acceleration as a text string.
    """
    return "Time Zoom:    {0:8.1f}".format(float(self.timezoom()))
    
</t>
<t tx="leo.20181129171705.114">def shipTimeText(self):
    """
    Report the elapsed time as a text string.
    """
    return "Elapsed Time: {0:8.1f} s".format(float(self.shiptime))



        
</t>
<t tx="leo.20181129171705.115">def dynamics(self, timer):
    """
    Perform one iteration of the simulation using runge-kutta 4th order method.
    """
    # set time duration equal to time since last execution
    tick = 10**self.timezoom()*(timer.time - self.lasttime)
    self.shiptime = self.shiptime + tick
    self.lasttime = timer.time
    # 4th order runge-kutta method (https://sites.temple.edu/math5061/files/2016/12/final_project.pdf)
    # and http://spiff.rit.edu/richmond/nbody/OrbitRungeKutta4.pdf  (succinct, but with a typo)
    self.A = k1v = self.ar(self._xy)
    k1r = self.V
    k2v = self.ar(self.vadd(self._xy, self.vmul(tick/2, k1r)))
    k2r = self.vadd(self.V, self.vmul(tick/2, k1v))
    k3v = self.ar(self.vadd(self._xy, self.vmul(tick/2, k2r)))
    k3r = self.vadd(self.V, self.vmul(tick/2, k2v))
    k4v = self.ar(self.vadd(self._xy, self.vmul(tick, k3r)))
    k4r = self.vadd(self.V, self.vmul(tick, k3v))
    self.V = [self.V[i] + tick/6*(k1v[i] + 2*k2v[i] + 2*k3v[i] + k4v[i]) for i in (0,1)]
    self._xy = [self._xy[i] + tick/6*(k1r[i] + 2*k2r[i] + 2*k3r[i] + k4r[i]) for i in (0,1)]
    if self.altitude &lt; 0:
        self.V = [0,0]
        self.A = [0,0]
        self.altitude = 0

# generic force as a function of position
</t>
<t tx="leo.20181129171705.116">def fr(self, pos):
    """
    Compute the net force vector on the rocket, as a function of the 
    position vector.
    """
    self.rotation = self.heading()
    t = self.thrust()
    G = 6.674E-11
    r = Planet.distance((0,0), pos)
    uvec = (-pos[0]/r, -pos[1]/r)
    fg = G*self.mass()*self.planet.mass/r**2
    F = [x*fg for x in uvec]
    return [F[0] + t*cos(self.rotation), F[1] + t*sin(self.rotation)]

# geric acceleration as a function of position
</t>
<t tx="leo.20181129171705.117">def ar(self, pos):
    """
    Compute the acceleration vector of the rocket, as a function of the 
    position vector.
    """
    m = self.mass()
    F = self.fr(pos)
    return [F[i]/m for i in (0,1)]
    
</t>
<t tx="leo.20181129171705.118">def vadd(self, v1, v2):
    """
    Vector add utility.
    """
    return [v1[i]+v2[i] for i in (0,1)]

</t>
<t tx="leo.20181129171705.119">def vmul(self, s, v):
    """
    Scalar vector multiplication utility.
    """
    return [s*v[i] for i in (0,1)]
    
</t>
<t tx="leo.20181129171705.12">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.120">def vmag(self, v):
    """
    Vector magnitude function.
    """
    return sqrt(v[0]**2 + v[1]**2)

</t>
<t tx="leo.20181129171705.121">def fgrav(self):
    """
    Vector force due to gravity, at current position.
    """
    G = 6.674E-11
    r = self.r
    uvec = (-self._xy[0]/r, -self._xy[1]/r)
    F = G*self.mass()*self.planet.mass/r**2
    return [x*F for x in uvec]

</t>
<t tx="leo.20181129171705.122">def turn(self, event):
    """
    Respond to left/right turning key events.
    """
    increment = pi/50 * (1 if event.key == "left arrow" else -1)
    self.localheading += increment

</t>
<t tx="leo.20181129171705.123">def _getposition(self):
    return self._xy

</t>
<t tx="leo.20181129171705.124">@property
def xyposition(self):
    return self._xy
    
</t>
<t tx="leo.20181129171705.125">@xyposition.setter
def xyposition(self, pos):
    self._xy = pos
    #self._touchAsset()

</t>
<t tx="leo.20181129171705.126">@property
def tanomalyd(self):
    return degrees(self.tanomaly)
    
</t>
<t tx="leo.20181129171705.127">@tanomalyd.setter
def tanomalyd(self, angle):
    self.tanomaly = radians(angle)

</t>
<t tx="leo.20181129171705.128">@property
def altitude(self):
    alt = Planet.distance(self._xy, (0,0)) - self.planet.radius
    return alt
    
</t>
<t tx="leo.20181129171705.129">@altitude.setter
def altitude(self, alt):
    r = alt + self.planet.radius
    self._xy = (r*cos(self.tanomaly), r*sin(self.tanomaly))

</t>
<t tx="leo.20181129171705.13"># gglogic boolean logic device simulations for ggmath
@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.130">@property
def velocity(self):
    return self.vmag(self.V)

</t>
<t tx="leo.20181129171705.131">@property
def acceleration(self):
    return self.vmag(self.A)
    
</t>
<t tx="leo.20181129171705.132">@property
def tanomaly(self):
    #pos = self._pos()
    return atan2(self._xy[1],self._xy[0])
    
</t>
<t tx="leo.20181129171705.133">@tanomaly.setter
def tanomaly(self, angle):
    r = self.r
    self._xy = (r*cos(angle), r*sin(angle))
    self._touchAsset()
        
</t>
<t tx="leo.20181129171705.134">@property
def r(self):
    return self.altitude + self.planet.radius

    
    



</t>
<t tx="leo.20181129171705.135">class Planet(MathApp):
    """
    Initialize the Planet object. 

    Optional keyword parameters are supported:
    
    * **viewscale**  pixels per meter in graphics display. Default is 10.
    * **radius**  radius of the planet in meters. Default is Earth radius.
    * **planetmass** mass of the planet in kg. Default is Earth mass.
    * **color** color of the planet. Default is greenish (0x008040).
    * **viewalt** altitude of initial viewpoint in meters. Default is rocket 
      altitude.
    * **viewanom** true anomaly (angle) of initial viewpoint in radians. 
      Default is the rocket anomaly.
    * **viewanomd** true anomaly (angle) of initial viewpoing in degrees.
      Default is the rocket anomaly.
    
    """
    
    @others
</t>
<t tx="leo.20181129171705.136">def __init__(self, **kwargs):
    scale = kwargs.get('viewscale', 10)  # 10 pixels per meter default
    self.radius = kwargs.get('radius', 6.371E6) # Earth - meters
    self.mass = kwargs.get('planetmass', 5.9722E24) # Earth - kg
    self.color = kwargs.get('color', 0x008040)  # greenish
    self.kwargs = kwargs # save it for later..
    super().__init__(scale)

</t>
<t tx="leo.20181129171705.137">def run(self, rocket=None):
    """
    Execute the Planet (and Rocket) simulation.

    Optional parameters:
    
    * **rocket** Reference to a Rocket object - sets the initial view
    """
    if rocket:
        viewalt = rocket.altitude
        viewanom = rocket.tanomaly
    else:
        viewalt = 0
        viewanom = pi/2
    self.viewaltitude = self.kwargs.get('viewalt', viewalt) # how high to look
    self.viewanomaly = self.kwargs.get('viewanom', viewanom)  # where to look
    self.viewanomalyd = self.kwargs.get('viewanomd', degrees(self.viewanomaly))
    self._planetcircle = Circle(
        (0,0), 
        self.radius, 
        style = LineStyle(1, Color(self.color,1)), 
        color = Color(self.color,0.5))
    r = self.radius + self.viewaltitude
    self.viewPosition = (r*cos(self.viewanomaly), r*sin(self.viewanomaly))
    super().run()
</t>
<t tx="leo.20181129171705.138">from ggame.mathapp import MathApp, _MathVisual
from ggame.asset import CircleAsset, PolygonAsset, Color, LineStyle
from math import sqrt

</t>
<t tx="leo.20181129171705.139">class Circle(_MathVisual):
    """
    Create a circle on the screen. This is a subclass of 
    :class:`~ggame.sprite.Sprite` and 
    :class:`~ggame.mathapp._MathVisual` but most of the inherited members are of
    little use and are not shown in the documentation.

    :param \*args:
        See below
    :param \**kwargs:
        See below

    :Required Arguments:
        * **pos** (*tuple(float,float)*) Center point of the circle, which may
            be a literal tuple of floats, or a reference to any object or 
            function that returns or evaluates to a tuple of floats.
        * **radius** [float or Point] Radius of the circle (logical units)
            or a :class:`~ggame.point.Point` on the circle.
    
    
    :Optional Keyword Arguments:
        * **positioning** (*str*) One of 'logical' or 'physical'
        * **style** (*LineStyle*) Valid :class:`~ggame.asset.LineStyle` object
        * **color** (*Color*) Valid :class:`~ggame.color.Color` object`
        
    Example::
    
        from ggame.point import Point
        from ggame.circle import Circle
        from ggame.mathapp import MathApp
        
        p1 = Point((2,1))
        c = Circle(p1, 1.4)
    
        MathApp().run()
    """

    _posinputsdef = ['pos']
    _nonposinputsdef = ['radius']
    _defaultcolor = Color(0,0)
    
    @others
</t>
<t tx="leo.20181129171705.14">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.140">def __init__(self, *args, **kwargs):
    super().__init__(CircleAsset(0, self._defaultstyle, self._defaultcolor), *args, **kwargs)
    self._touchAsset()
    self.fxcenter = self.fycenter = 0.5


</t>
<t tx="leo.20181129171705.141">def _buildAsset(self):
    pcenter = self._spposinputs.pos
    try: 
        pradius = MathApp.distance(self._posinputs.pos(), self._nposinputs.radius()) * MathApp._scale
    except (AttributeError, TypeError):
        pradius = self._nposinputs.radius() * MathApp._scale
    style = self._stdinputs.style()
    fill = self._stdinputs.color()
    ymax = pcenter[1]+pradius
    ymin = pcenter[1]-pradius
    xmax = pcenter[0]+pradius
    xmin = pcenter[0]-pradius
    try:
        if ymin &gt; MathApp.height or ymax &lt; 0 or xmax &lt; 0 or xmin &gt; MathApp.width:
            return CircleAsset(pradius, style, fill)
        elif pradius &gt; 2*MathApp.width:
            # here begins unpleasant hack to overcome crappy circles
            poly = self._buildPolygon(pcenter, pradius)
            if len(poly):
                passet = PolygonAsset(poly, style, fill)
                return passet
    except AttributeError:
        return CircleAsset(pradius, style, fill)
    return CircleAsset(pradius, style, fill)

</t>
<t tx="leo.20181129171705.142">def _buildPolygon(self, pcenter, pradius):
    """
    pcenter is in screen relative coordinates.
    returns a coordinate list in circle relative coordinates
    """
    xcepts = [self._findIntercepts(pcenter, pradius, 0,0,0,MathApp.height),
        self._findIntercepts(pcenter, pradius, 0,0,MathApp.width,0),
        self._findIntercepts(pcenter, pradius, MathApp.width,0,MathApp.width,MathApp.height),
        self._findIntercepts(pcenter, pradius, 0,MathApp.height, MathApp.width, MathApp.height)]
    ilist = []
    for x in xcepts:
        if x and len(x) &lt; 2:
            ilist.extend(x)
    #ilist is a list of boundary intercepts that are screen-relative
    if len(ilist) &gt; 1:
        xrange = ilist[-1][0] - ilist[0][0]
        yrange = ilist[-1][1] - ilist[0][1]
        numpoints = 20
        inx = 0
        for i in range(numpoints):
            icepts =  self._findIntercepts(pcenter, pradius, 
                pcenter[0], pcenter[1], 
                ilist[0][0] + xrange*(i+1)/(numpoints+1),
                ilist[0][1] + yrange*(i+1)/(numpoints+1))
            if len(icepts):
                ilist.insert(inx+1, icepts[0])
                inx = inx + 1
        self._addBoundaryVertices(ilist, pcenter, pradius)
        ilist.append(ilist[0])
        ilist = [(i[0] - pcenter[0], i[1] - pcenter[1]) for i in ilist]
    return ilist
    
</t>
<t tx="leo.20181129171705.143">def _addBoundaryVertices(self, plist, pcenter, pradius):
    """
    Sides 0=top, 1=right, 2=bottom, 3=left
    """
    #figure out rotation in point sequence
    cw = 0
    try:
        rtst = plist[0:3]+[plist[0]]
        for p in range(3):
            cw = cw + (rtst[p+1][0]-rtst[p][0])*(rtst[p+1][1]+rtst[p][1])
    except IndexError:
        #print(plist)
        return
    cw = self._sgn(cw)
    cw = 1 if cw &lt; 0 else 0
    vertices = ((-100,-100),
        (MathApp.width+100,-100),
        (MathApp.width+100,MathApp.height+100),
        (-100,MathApp.height+100))
    nextvertex = [(vertices[0],vertices[1]),
                    (vertices[1],vertices[2]),
                    (vertices[2],vertices[3]),
                    (vertices[3],vertices[0])]
    nextsides = [(3,1),(0,2),(1,3),(2,0)]
    edges = ((None,0),(MathApp.width,None),(None,MathApp.height),(0,None))
    endside = startside = None
    for side in range(4):
        if endside is None and (edges[side][0] == round(plist[-1][0]) or edges[side][1] == round(plist[-1][1])):
            endside = side
        if startside is None and (edges[side][0] == round(plist[0][0]) or edges[side][1] == round(plist[0][1])):
            startside = side
    iterations = 0
    while startside != endside:
        iterations = iterations + 1
        if iterations &gt; 20:
            break
        if endside != None and startside != None:   #  and endside != startside
            plist.append(nextvertex[endside][cw])
            endside = nextsides[endside][cw]

</t>
<t tx="leo.20181129171705.144">def _sgn(self, x):
    return 1 if x &gt;= 0 else -1

</t>
<t tx="leo.20181129171705.145">def _findIntercepts(self, c, r, x1, y1, x2, y2):
    """
    c (center) and x and y values are physical, screen relative.
    function returns coordinates in screen relative format
    """
    x1n = x1 - c[0]
    x2n = x2 - c[0]
    y1n = y1 - c[1]
    y2n = y2 - c[1]
    dx = x2n-x1n
    dy = y2n-y1n
    dr = sqrt(dx*dx + dy*dy)
    D = x1n*y2n - x2n*y1n
    disc = r*r*dr*dr - D*D
    dr2 = dr*dr
    if disc &lt;= 0:  # less than two solutions
        return []
    sdisc = sqrt(disc)
    x = [(D*dy + self._sgn(dy)*dx*sdisc)/dr2 + c[0],  (D*dy - self._sgn(dy)*dx*sdisc)/dr2 + c[0]]
    y = [(-D*dx + abs(dy)*sdisc)/dr2 + c[1], (-D*dx - abs(dy)*sdisc)/dr2 + c[1]]
    getcoords = lambda x, y, c: [(x,y)] if x&gt;=0 and x&lt;=MathApp.width and y&gt;=0 and y&lt;=MathApp.height else []
    res = getcoords(x[0], y[0], c)
    res.extend(getcoords(x[1], y[1], c))
    return res


</t>
<t tx="leo.20181129171705.146">@property
def center(self):
    return self._center()

</t>
<t tx="leo.20181129171705.147">@center.setter
def center(self, val):
    """
    An ordered pair (x,y) or :class:`~ggame.point.Point` that represents 
    the (logical) circle center. This attribute is set-able and get-able.
    """
    newval = self.Eval(val)
    if newval != self._center:
        self._center = newval
        self._touchAsset()

</t>
<t tx="leo.20181129171705.148">@property
def radius(self):
    return self._radius()

</t>
<t tx="leo.20181129171705.149">@radius.setter
def radius(self, val):
    newval = self.Eval(val)
    """
    A **float** that represents the radius of the circle. This attribugte
    is set-able and get-able.
    """
    if newval != self._radius:
        self._radius = newval
        self._touchAsset()
    
</t>
<t tx="leo.20181129171705.15">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.150">def step(self):
    self._touchAsset()

</t>
<t tx="leo.20181129171705.151">def physicalPointTouching(self, ppos):
    r = MathApp.distance(self._pcenter, ppos)
    inner = self._pradius - self.style.width/2
    outer = self._pradius + self.style.width/2
    return r &lt;= outer and r &gt;= inner

</t>
<t tx="leo.20181129171705.152">def translate(self, pdisp):
    pass

</t>
<t tx="leo.20181129171705.16">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.17">@others
if module_exists('pygame'):

  import pygame
  
  class _body(object):
    
    def __init__(self):
      self.events = {}

    def appendChild(self, obj):
      self.child = obj

    def bind(self, evt, action):
      self.events[evt] = action
      print("Binding {} to {}".format(evt, action))

  class _document(object):
    
    def __init__(self):
      self.body = _body()

  class _window(object):

    def __init__(self):
      self.document = _document()
      self.animatex = 0

    def open(self, s1, s2):
      return self

    def requestAnimationFrame(self, target):
      if self.animatex &lt; 10:
        self.animatex += 1
        target('dummy')
        print("Animation frame")

  class _Container(object):

    def __init__(self):
      pass

    def destroy(self):
      pass

  class _Renderer(object):
    
    def __init__(self, x, y, argsdict):
      self.x = x
      self.y = y
      self.argsdict = argsdict
      self.view = 'view'
      print("Rendering created with {}x{} area".format(x, y))

    def render(self, stage):
      pass

  class _GFX(object):
    
    def __init__(self):
      self.Container = _Container
      self.autoDetectRenderer = _Renderer

  window = _window()

  GFX = _GFX()

  #document = object()
  
  def JSConstructor(cls):
    return cls
    
  def JSObject(obj):
    return obj
  
  class _GFX_Rectangle(pygame.Rect):
    pass
  
  GFX_Rectangle = _GFX_Rectangle
 
  class _Texture(object):
 
    def __init__(self, img='', crossdomain=False):
      self.name = img
      if not img == '':
        self.img = pygame.image.load(img)  # pygame surface
        self.basewidth = self.img.get_width()
        self.baseheight = self.img.get_height()
        self.width = self.basewidth
        self.height = self.baseheight
        print("Texture from image {}, {}x{} pixels".format(img, self.basewidth, self.baseheight))
        self.baserect = _GFX_Rectangle(0, 0, self.basewidth, self.baseheight)
        self.framerect = self.baserect

    def fromTexture(cls, texture, frame):
      inst = cls()
      inst.img = pygame.Surface((frame.width, frame.height))
      inst.img.blit(texture.img, (0,0), frame)
      inst.name = texture.name
      inst.basewidth = texture.basewidth
      inst.baseheight = texture.baseheight
      inst.baserect = texture.baserect
      inst.framerect = frame
      inst.width = frame.width
      inst.height = frame.height
      print("Texture from base texture {}, {}x{} subframe {}x{}".format(inst.name, inst.basewidth, inst.baseheight, inst.framerect.width, inst.framerect.height))
      return inst

    def destroy(self):
      try:
        self.img.close()
        print("Destroying an image")
      except:
        print("Destroying a non-image")

  GFX_Texture = _Texture.fromTexture
  
  GFX_Texture_fromImage = _Texture  


  class vector(object):
  
    def __init__(self, x, y):
      self.x = x
      self.y = y

    def __getitem__(self, key):
      if key == 0:
        return self.x
      elif key == 1:
        return self.y
      else:
        raise KeyError

    def __setitem(self, key, value):
      if key == 0:
        self.x = value
      elif key == 1:
        self.y = value
      else:
        raise KeyError
  
  class GFX_Sprite(object):
    
    def __init__(self, texture):
      self.basetexture = texture
      self.texture = self.basetexture
      self.visible = True
      self.pos = vector(0,0)
      self.anch = vector(0,0)
      self.scal = vector(1.0, 1.0)
      self.width = texture.width
      self.height = texture.height
      self.rotation = 0.0

    def position(self):
      return self.pos

    def position(self, value):
      self.pos.x = value[0]
      self.pos.y = value[1]

    def anchor(self):
      return self.anch
 
    def anchor(self, value):
      self.anch.x = value[0]
      self.anch.y = value[1]

    def scale(self):
      return self.scal

    def scale(self, value):
      self.scal.x = value[0]
      self.scal.y = value[1]

    def destroy(self):
      pass

  class _GFX_Graphics(object):

    def __init__(self):
      self.clear()

    def clear(self):
      self.cleared = True
      self.visible = True
      self.lwidth = None
      self.color = None
      self.alpha = None
      self.fillcolor = None
      self.fillalpha = None
      self.x = None
      self.y = None
      self.rwidth = None
      self.rheight = None
      self.radius = None
      self.ehw = None
      self.ehh = None
      self.xto = None
      self.yto = None
      self.jpath = None
      self.width = None
      self.height = None
      self.position = vector(0,0)

    def destroy(self):
      self.clear()

    def clone(self):
      clone = type(self)()
      clone.cleared = self.cleared
      clone.visible = self.visible
      clone.lwidth = self.lwidth
      clone.color = self.color
      clone.alpha = self.alpha
      clone.fillalpha = self.fillalpha
      clone.fillcolor = self.fillcolor
      clone.x = self.x
      clone.y = self.y
      clone.rwidth = self.rwidth
      clone.rheight = self.rheight
      clone.radius = self.radius
      clone.ehw = self.ehw
      clone.ehh = self.ehh
      clone.xto = self.xto
      clone.yto = self.yto
      clone.jpath = self.jpath
      clone.width = self.width
      clone.height = self.height
      clone.position = self.position
      return clone

    def lineStyle(self, width, color, alpha):
      self.width = width
      self.color = color
      self.alpha = alpha

    def beginFill(self, color, alpha):
      self.fillcolor = color
      self.fillalpha = alpha

    def drawRect(self, x, y, w, h):
      self.x = x
      self.y = y
      self.position = vector(x,y)
      self.rwidth = w
      self.rheight = h
      self.width = w
      self.height = h
      self.cleared = False
      print("Rectangle {}x{} at {},{}".format(w,h,x,y))
      return self

    def drawCircle(self, x, y, radius):
      self.x = x
      self.y = y
      self.position = vector(x,y)
      self.radius = radius
      self.cleared = False
      self.width = radius*2
      self.height = radius*2
      print("Circle, radius {} at {},{}".format(radius,x,y))
      return self  

    def drawEllipse(self, x, y, hw, hh):
      self.x = x
      self.y = y
      self.position = vector(x,y)
      self.ehw = hw
      self.ehh = hh
      self.width = hw*2
      self.height = hh*2
      self.cleared = False
      print("Ellipse, {}x{} at {},{}".format(hw,hh,x,y))
      return self

    def drawPolygon(self, jpath):
      self.jpath = jpath
      self.cleared = False
      self.position = vector(jpath[0],jpath[1])
      x = []
      y = []
      for i in range(0,len(jpath)-1,2):
        x.append(jpath[i])
        y.append(jpath[i+1])
      self.width = max(x)-min(x)
      self.height = max(y)-min(y)
      print("Polygon")
      return self

    def moveTo(self, x, y):
      self.x = x
      self.y = y
      self.position = vector(x,y)
      return self

    def lineTo(self, x, y):
      self.xto = x
      self.yto = y
      self.width = abs(x)
      self.height = abs(y)
      self.cleared = False
      print("Line from {},{} to {},{}".format(self.x, self.y, x, y))
      return self 

  class _GFX_Text(object):

    def __init__(self, text, styledict):
      self.text = text
      self.styledict = styledict
      self.alpha = None
      self.visible = None
      self.width = 99
      self.height = 99
      self.position = vector(0,0)
      print("Text: {} in {}".format(text, styledict['font']))

    def clone(self):
      clone = type(self)(self.text, self.styledict)
      return clone

    def destroy(self):
      self.text = ''


  GFX_Text = _GFX_Text

  _globalGraphics = _GFX_Graphics()

  GFX_Graphics = _globalGraphics

  def GFX_DetectRenderer():
    pass
 
  class _SND_all(object):

    def __init__(self):
      pass

    def stop(self):
      print("Stopping all sounds")

  class _SND(object):
    
    def __init__(self):
      self.all = _SND_all

  SND = _SND()
  
  class _SND_Sound(object):

    def __init__(self, url):
      self.url = url
      print("Creating sound object {}".format(url))

    def load(self):
      pass

    def play(self):
      print("Playing sound object {}".format(self.url))

  SND_Sound = _SND_Sound


  class HwEvent(object):

    evtmap = {2: 'keydown', 3: 'keyup', 4: 'mousemove', 5: 'mousedown', 6: 'mouseup'}
    keymap = {304:16,
              303:16,
              306:17,
              308:18,
              301:20,
              276:37,
              273:38,
              275:39,
              274:40,
              97:65,
              98:66,
              99:67,
              100:68,
              101:69,
              102:70,
              103:71,
              104:72,
              105:73,
              106:74,
              107:75,
              108:76,
              109:77,
              110:78,
              111:79,
              112:80,
              113:81,
              114:82,
              115:83,
              116:84,
              117:85,
              118:86,
              119:87,
              120:88,
              121:89,
              122:90,
              282:112,
              283:113,
              284:114,
              285:115,
              286:116,
              287:117,
              288:118,
              289:119,
              290:120,
              291:121,
              292:122,
              293:123,
              59:186,
              61:187,
              44:188,
              46:190,
              45:189,
              47:191,
              96:192,
              92:220,
              91:219,
              93:221,
              39:222}

    def __init__(self, pevent):
      self.type = HwEvent.evtmap.get(pevent.type, None)
      if self.type in ['keydown', 'keyup']:
        self.keyCode = HwEvent.keymap.get(pevent.key, pevent.key)
      elif self.type in ['mousemove', 'mousedown', 'mouseup']:
        self.wheelDelta = 0
        if self.type != 'mousemove' and pevent.button == 5:
          if self.type == 'mousedown':
            self.wheelDelta = 1
          else:
            self.wheelDelta = -1
        self.clientX = pevent.pos[0]
        self.clientY = pevent.pos[1]

  class GFX_Window(object):
    
    def __init__(self, width, height, onclose):
      pygame.init()
      self._w = pygame.display.set_mode((width, height))
      self.clock = pygame.time.Clock()
      self.sprites = []
      self.animatestarted = False
      self.bindings = {}
      self.onclose = onclose
      self.stop = False
      #self._w = window.open("", "")
      #self._stage = JSConstructor(GFX.Container)()
      #self._renderer = GFX.autoDetectRenderer(width, height, {'transparent':True})
      #self._w.document.body.appendChild(self._renderer.view)
      #self._w.onunload = onclose
  
    def bind(self, evtspec, callback):
      self.bindings[evtspec] = callback

    def add(self, obj):
      self.sprites.append(obj)
      #self._stage.addChild(obj)
      
    def remove(self, obj):
      self.sprites.remove(obj)
      #self._stage.removeChild(obj)
      
    def animate(self, stepcallback):
      # do stuff required to display
      self._w.fill(pygame.Color('white'))
      for s in self.sprites:
        self._w.blit(s.texture.img, (s.pos.x, s.pos.y))
      pygame.display.flip()
      events = pygame.event.get()
      for event in events:
        hwevent = HwEvent(event)
        if hwevent.type != None:
          self.bindings[hwevent.type](hwevent)
        if event.type == 12:
          print("Close!")
          self.onclose()
          self.destroy()
          self.stop = True
      if not self.animatestarted:
        self.animatestarted = True
        while not self.stop:
          self.clock.tick_busy_loop(30)
          stepcallback(0)
      #self._renderer.render(self._stage)
      #self._w.requestAnimationFrame(stepcallback)
      
    def destroy(self):
      pass
      #SND.all().stop()
      #self._stage.destroy()
  

@language python
@tabwidth -4
@ignore
</t>
<t tx="leo.20181129171705.18">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.19">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.2"># app.py

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.20">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.21">@others
if module_exists('browser') and module_exists('javascript'):

    from browser import window, document, load
    from javascript import JSObject, JSConstructor
    #load("https://cdnjs.cloudflare.com/ajax/libs/pixi.js/3.0.5/pixi.min.js")
    #load("https://cdnjs.cloudflare.com/ajax/libs/buzz/1.1.10/buzz.min.js")
    #load("static/pixi-4.8.2.min.js")
    load("static/pixi-3.0.5.min.js")
    load("static/buzz-1.2.1.js")
    major = window.__BRYTHON__.implementation[0]
    minor = window.__BRYTHON__.implementation[1]
    if major == 3 and minor &gt;= 3 or major &gt; 3:
        GFX = window.PIXI
        GFX_Rectangle = GFX.Rectangle.new
        GFX_Texture = GFX.Texture.new
        GFX_Texture_fromImage = GFX.Texture.fromImage.new
        GFX_Sprite = GFX.Sprite.new
        GFX_Graphics = GFX.Graphics.new()
        GFX_Text = GFX.Text.new
        GFX_NewStage = GFX.Container.new
        SND = window.buzz
        SND_Sound = SND.sound.new
    else:
        GFX = JSObject(window.PIXI)
        GFX_Rectangle = JSConstructor(GFX.Rectangle)
        GFX_Texture = JSConstructor(GFX.Texture)
        GFX_Texture_fromImage = JSConstructor(GFX.Texture.fromImage)
        GFX_Sprite = JSConstructor(GFX.Sprite)
        GFX_Graphics = JSConstructor(GFX.Graphics)()
        GFX_Text = JSConstructor(GFX.Text)
        GFX_NewStage = JSConstructor(GFX.Container)
        SND = JSObject(window.buzz)
        SND_Sound = JSConstructor(SND.sound)
    GFX_DetectRenderer = GFX.autoDetectRenderer 
  
    class GFX_Window(object):
        
        def __init__(self, width, height, onclose):
            canvas = window.document.getElementById('ggame-canvas')
            if canvas:
                self._w = window
                window.bsUI.graphicsmode()
                options = {'transparent':True, 'antialias':True, 'view':canvas}
                attachpoint = window.document.getElementById('graphics-column')
                w, h = attachpoint.clientWidth, attachpoint.clientHeight
            else:
                # 假如要執行時額外跳出一個視窗
                #self._w = window.open("", "")
                # 在原先的視窗中執行
                self._w = window
                w, h = self._w.innerWidth * 0.9, self._w.innerHeight * 0.9
                options = {'transparent':True, 'antialias':True}
                attachpoint = self._w.document.body
            GFX.utils._saidHello = True; # ugly hack to block pixi banner
            self._stage = GFX_NewStage()
            self.width = width if width != 0 else int(w)
            self.height = height if height != 0 else int(h)
            self._renderer = GFX.autoDetectRenderer(self.width, self.height, options)
            attachpoint.appendChild(self._renderer.view)
            self._w.onunload = onclose
      
        def bind(self, evtspec, callback):
            self._w.document.body.unbind(evtspec) # in case already bound
            self._w.document.body.bind(evtspec, callback)

        def unbind(self, evtspec):
            self._w.document.body.unbind(evtspec)
          
        def add(self, obj):
            self._stage.addChild(obj)
          
        def remove(self, obj):
            self._stage.removeChild(obj)
          
        def animate(self, stepcallback):
            self._renderer.render(self._stage)
            self._w.requestAnimationFrame(stepcallback)
          
        def destroy(self):
            SND.all().stop()
            self._stage.destroy()
  

elif module_exists('pygame'):

    try:
        from ggame.pygamedeps import *
    except ImportError:
        from pygamedeps import *

else:
    try:
        from ggame.headlessdeps import *
    except ImportError:
        from headlessdeps import *
  
    
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.22">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.23">try:
    from ggame.sysdeps import *
except:
    from sysdeps import *

from ggame.asset import *
from ggame.event import *

</t>
<t tx="leo.20181129171705.24">class App(object):
    """
    The :class:`App` class is a (typically subclassed) class that encapsulates
    handling of the display system, and processing user events. The :class:`App` 
    class also manages lists of all :class:`Sprite` instances in the application.

    When subclassing :class:`App` you may elect to instantiate most of your
    sprite objects in the initialization section.

    Processing that must occur on a per-frame basis may be included by overriding
    the :meth:`~App.run` method. This is also an appropriate location to call
    similar 'step' methods for your various customized sprite classes.

    Once your application class has been instantiated, begin the frame drawing
    process by calling its :meth:`~App.run` method.

    The :class:`App` class is instantiated either by specifying the desired app 
    window size in pixels, as two parameters:::
    
        myapp = App(640,480)
    
    or by providing no size parameters at all:::
    
        myapp = App()
    
    in which case, the full browser window size is used.

    NOTE: Only **one** instance of an :class:`App` class or subclass may be 
    instantiated at a time.
    """
    
    spritelist = []
    """
    List of all sprites currently active in the application.
    """
    _eventdict = {}
    _spritesdict = {}
    _spritesadded = False
    _win = None

    @others
</t>
<t tx="leo.20181129171705.25">def __init__(self, *args):
    if App._win == None and (len(args) == 0 or len(args) == 2):
        x = y = 0
        if len(args) == 2:
            x = args[0]
            y = args[1]
        App._win = GFX_Window(x, y, type(self)._destroy)
        self.width = App._win.width
        self.height = App._win.height
        # Add existing sprites to the window
        if not App._spritesadded and len(App.spritelist) &gt; 0:
            App._spritesadded = True
            for sprite in App.spritelist:
                App._win.add(sprite.GFX)
        App._win.bind(KeyEvent.keydown, self._keyEvent)
        App._win.bind(KeyEvent.keyup, self._keyEvent)
        App._win.bind(KeyEvent.keypress, self._keyEvent)
        App._win.bind(MouseEvent.mousewheel, self._mouseEvent)
        App._win.bind(MouseEvent.mousemove, self._mouseEvent)
        App._win.bind(MouseEvent.mousedown, self._mouseEvent)
        App._win.bind(MouseEvent.mouseup, self._mouseEvent)
        App._win.bind(MouseEvent.click, self._mouseEvent)
        App._win.bind(MouseEvent.dblclick, self._mouseEvent)

</t>
<t tx="leo.20181129171705.26">def _routeEvent(self, event, evtlist):
    for callback in reversed(evtlist):
        if not event.consumed:
            callback(event)
    
</t>
<t tx="leo.20181129171705.27">def _keyEvent(self, hwevent):
    evtlist = App._eventdict.get(
        (hwevent.type, KeyEvent.keys.get(hwevent.keyCode,0)), [])
    evtlist.extend(App._eventdict.get((hwevent.type, '*'), []))
    if len(evtlist) &gt; 0:
        evt = KeyEvent(hwevent)
        self._routeEvent(evt, evtlist)
    return False

</t>
<t tx="leo.20181129171705.28">def _mouseEvent(self, hwevent):
    evtlist = App._eventdict.get(hwevent.type, [])
    if len(evtlist) &gt; 0:
        evt = MouseEvent(type(self),hwevent)
        self._routeEvent(evt, evtlist)
    return False

</t>
<t tx="leo.20181129171705.29">@classmethod
def _add(cls, obj):
    if App._win != None:
        App._win.add(obj.GFX)
    App.spritelist.append(obj)
    if type(obj) not in App._spritesdict:
        App._spritesdict[type(obj)] = []
    App._spritesdict[type(obj)].append(obj)

</t>
<t tx="leo.20181129171705.3"># asset.py

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.30">@classmethod
def _remove(cls, obj):
    if App._win != None:
        App._win.remove(obj.GFX)
    App.spritelist.remove(obj)
    App._spritesdict[type(obj)].remove(obj)
    
</t>
<t tx="leo.20181129171705.31">def _animate(self, dummy):
    if self.userfunc:
        self.userfunc()
    else:
        self.step()
    if App._win:
        App._win.animate(self._animate)

</t>
<t tx="leo.20181129171705.32">@classmethod
def _destroy(cls, *args):
    """
    This will close the display window/tab, remove all references to 
    sprites and place the `App` class in a state in which a new 
    application could be instantiated.
    """ 
    if App._win:
        App._win.unbind(KeyEvent.keydown)
        App._win.unbind(KeyEvent.keyup)
        App._win.unbind(KeyEvent.keypress)
        App._win.unbind(MouseEvent.mousewheel)
        App._win.unbind(MouseEvent.mousemove)
        App._win.unbind(MouseEvent.mousedown)
        App._win.unbind(MouseEvent.mouseup)
        App._win.unbind(MouseEvent.click)
        App._win.unbind(MouseEvent.dblclick)
        App._win.destroy()
    App._win = None
    for s in list(App.spritelist):
        s.destroy()
    App.spritelist = []
    App._spritesdict = {}
    App._eventdict = {}
    App._spritesadded = False

</t>
<t tx="leo.20181129171705.33">@classmethod
def listenKeyEvent(cls, eventtype, key, callback):
    """
    Register to receive keyboard events. 

    :param str eventtype:  The type of key event to 
        receive (value is one of: `'keydown'`, `'keyup'` or `'keypress'`). 
        
    :param str key:  Identify the keyboard key (e.g. `'space'`, 
        `'left arrow'`, etc.) to receive events for.
        
    :param function callback:  The function or method that will be 
        called with the :class:`~ggame.event.KeyEvent` object when the event occurs.
        
    :returns: Nothing

    See the source for :class:`~ggame.event.KeyEvent` for a list of key names
    to use with the `key` paramter.
    """
    evtlist = App._eventdict.get((eventtype, key), [])
    if not callback in evtlist:
        evtlist.append(callback)
    App._eventdict[(eventtype, key)] = evtlist

</t>
<t tx="leo.20181129171705.34">@classmethod
def listenMouseEvent(cls, eventtype, callback):
    """
    Register to receive mouse events. 
    
    :param str eventtype: The type of mouse event to 
        receive (value is one of: `'mousemove'`, `'mousedown'`, `'mouseup'`,
        `'click'`, `'dblclick'` or `'mousewheel'`). 
    
    :param function callback: The function or method that will be 
        called with the :class:`ggame.event.MouseEvent` object when the event occurs.
        
    :returns: Nothing
    """
    evtlist = App._eventdict.get(eventtype, [])
    if not callback in evtlist:
        evtlist.append(callback)
    App._eventdict[eventtype] = evtlist

</t>
<t tx="leo.20181129171705.35">@classmethod
def unlistenKeyEvent(cls, eventtype, key, callback):
    """
    Use this method to remove a registration to receive a particular
    keyboard event. Arguments must exactly match those used when
    registering for the event.
    
    :param str eventtype:  The type of key event to stop
        receiving (value is one of: `'keydown'`, `'keyup'` or `'keypress'`). 
        
    :param str key:  The keyboard key (e.g. `'space'`, 
        `'left arrow'`, etc.) to stop receiving events for.
        
    :param function callback:  The function or method that will no longer be
        called with the :class:`~ggame.event.KeyEvent` object when the event occurs.
        
    :returns: Nothing

    See the source for :class:`~ggame.event.KeyEvent` for a list of key names
    to use with the `key` paramter.
    
    """
    App._eventdict[(eventtype,key)].remove(callback)

</t>
<t tx="leo.20181129171705.36">@classmethod
def unlistenMouseEvent(cls, eventtype, callback):
    """
    Use this method to remove a registration to receive a particular
    mouse event. Arguments must exactly match those used when
    registering for the event.
    
    :param str eventtype: The type of mouse event to stop receiving events
        for (value is one of: `'mousemove'`, `'mousedown'`, `'mouseup'`,
        `'click'`, `'dblclick'` or `'mousewheel'`). 
    
    :param function callback: The function or method that will no longer be 
        called with the :class:`ggame.event.MouseEvent` object when the event occurs.
        
    :returns: Nothing
    """
    App._eventdict[eventtype].remove(callback)

</t>
<t tx="leo.20181129171705.37">@classmethod
def getSpritesbyClass(cls, sclass):
    """
    Returns a list of all active sprites of a given class.
    
    :param class sclass: A class name (e.g. 'Sprite') or subclass.
    
    :returns: A (potentially empty) list of sprite references.
    """
    return App._spritesdict.get(sclass, [])

</t>
<t tx="leo.20181129171705.38">def step(self):
    """
    The :meth:`~App.step` method is called once per animation frame. Override
    this method in your own subclass of :class:`App` to perform periodic 
    calculations, such as checking for sprite collisions, or calling
    'step' functions in your own customized sprite classes.

    The base class :meth:`~App.step` method is empty and is intended to be overriden.
    
    :returns: Nothing
    
    """
    pass

</t>
<t tx="leo.20181129171705.39">def run(self, userfunc = None):
    """
    Calling the :meth:`~App.run` method begins the animation process whereby the 
    :meth:`~App.step` method is called once per animation frame. 
    
    :param function userfunc: Any function or method which shall be 
        called once per animation frame.
        
    :returns: Nothing
    """
    self.userfunc = userfunc
    App._win.animate(self._animate)


    
</t>
<t tx="leo.20181129171705.4">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.40">"""
ggame assets and related objects (:class:`Color` and :class:`LineStyle`) are
classes that encapsulate and represent displayable images. A single asset 
may be used in multiple sprites. Animated assets may be created from any 
image that includes multiple images within it (i.e. a sprite sheet).
"""

try:
    from ggame.sysdeps import *
except:
    from sysdeps import *

</t>
<t tx="leo.20181129171705.41">class Frame(object):
    """
    Frame is a utility class for expressing the idea of a rectangular region.
    
    Initializing parameters describe the position of the upper-left corner
    of the frame, and the frame's width and height. The units are *typically*
    in pixels, though a frame can be generic.
    
    :param int x: X-coordinate of frame upper-left corner
    :param int y: Y-coordinate of frame upper-left corner
    :param int w: Width of the frame
    :param int h: Height of the frame
    """
    
    @others
</t>
<t tx="leo.20181129171705.42">def __init__(self, x, y, w, h):

    self.GFX = GFX_Rectangle(x,y,w,h)
    """
    `GFX` is a reference to the underlying object provided by the system.
    """
    self.x = x
    self.y = y
    self.w = w
    self.h = h

</t>
<t tx="leo.20181129171705.43">@property
def x(self):
    """
    X-coordinate of the upper left hand corner of this frame.
    """
    return self.GFX.x

</t>
<t tx="leo.20181129171705.44">@x.setter
def x(self, value):
    self.GFX.x = value
    
</t>
<t tx="leo.20181129171705.45">@property
def y(self):
    """
    Y-coordinate of the upper left hand corner of this frame.
    """
    return self.GFX.y

</t>
<t tx="leo.20181129171705.46">@y.setter
def y(self, value):
    self.GFX.y = value

</t>
<t tx="leo.20181129171705.47">@property
def w(self):
    """
    Width of the frame.
    """
    return self.GFX.width

</t>
<t tx="leo.20181129171705.48">@w.setter
def w(self, value):
    self.GFX.width = value
    
</t>
<t tx="leo.20181129171705.49">@property
def h(self):
    """
    Height of the frame.
    """
    return self.GFX.height
    
</t>
<t tx="leo.20181129171705.5">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.50">@h.setter
def h(self, value):
    self.GFX.height = value

</t>
<t tx="leo.20181129171705.51">@property
def center(self):
    """
    The `center` property computes a coordinate pair (tuple) for the 
    center of the frame.

    The `center` property, when set, redefines the `x` and `y` properties
    of the frame in order to make the center agree with the coordinates
    (tuple) assigned to it.
    """

    return (self.x + self.w//2, self.y + self.h//2)

</t>
<t tx="leo.20181129171705.52">@center.setter
def center(self, value):
    c = self.center
    self.x += value[0] - c[0]
    self.y += value[1] - c[1]

</t>
<t tx="leo.20181129171705.53">class _Asset(object):
    """
    Base class for all game asset objects.
    
    The `ggame.Asset` class is set up to understand the concept
    of multiple instances of an asset. This is currently only used for image-based
    assets.
    """

    @others
</t>
<t tx="leo.20181129171705.54">def __init__(self):
    self.GFXlist = [None,]
    """A list of the underlying system objects used to represent this asset."""

</t>
<t tx="leo.20181129171705.55">@property
def GFX(self):
    """
    `GFX` property represents the underlying system object used to represent
    this asset. If this asset is composed of multiple assets, then the **first**
    asset is referenced by `GFX`.
    """
    return self.GFXlist[0]
    
</t>
<t tx="leo.20181129171705.56">@GFX.setter
def GFX(self, value):
    self.GFXlist[0] = value
    
</t>
<t tx="leo.20181129171705.57">def __len__(self):
    return len(self.GFXlist)
    
</t>
<t tx="leo.20181129171705.58">def __getitem__(self, key):
    return self.GFXlist[key]
    
</t>
<t tx="leo.20181129171705.59">def __setitem__(self, key, value):
    self.GFXlist[key] = value
    
</t>
<t tx="leo.20181129171705.6"># event.py

@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.60">def __iter__(self):
    class Iter():
        def __init__(self, image):
            self.obj = image
            self.n = len(image.GFXlist)
            self.i = 0
            
        def __iter__(self):
            return self
            
        def __next__(self):
            if self.i ==self.n:
                raise StopIteration
            self.i += 1
            return self.obj.GFXlist[self.i]
    return Iter(self)

</t>
<t tx="leo.20181129171705.61">def destroy(self):
    """
    Destroy or deallocate any underlying graphics resources used by the
    asset. Call this method on any asset that is no longer being used.
    """
    if hasattr(self, 'GFX'):
        try:
            for gfx in self.GFXlist:
                try:
                    gfx.destroy(True)
                except:
                    pass
        except:
            pass
    
    
</t>
<t tx="leo.20181129171705.62">class ImageAsset(_Asset):
    """
    The ImageAsset class connects ggame to a specific image **file**.

    :param str url: All ImageAsset instances must specify a file name or 
        url where a jpg or png image is located.

    :param Frame frame: If the desired sprite image exists in only a smaller 
        sub-section of the original image, then specify an area `within` the
        image using `frame` parameter, which must be a valid :class:`Frame` 
        instance.

    :param int qty=0: If the image file actually is a *collection* of images, such 
        as a so-called *sprite sheet*, then the ImageAsset class supports 
        defining a list of images, provided they exist in the original image 
        as a **row** of evenly spaced images or a **column** of images. To 
        specify this, provide the `qty` (quantity) of images in the row or 
        column.
    
    :param str direction='horizontal': For an image *sprite sheet*, specify whether the images
        are oriented in a `'vertical'` or `'horizontal'` arrangement.
        
    :param int margin=0: If there is a gap between successive images in an image
        *sprite sheet*, then specify the size of the gap (in pixels). When 
        used in this way, the `frame` parameter must define the
        area of only the **first** image in the collection; all subsequent 
        images in the list are assumed to be the same size, but separated by the
        `margin` value.
    """

    @others
</t>
<t tx="leo.20181129171705.63">def __init__(self, url, frame=None, qty=1, direction='horizontal', margin=0):
    super().__init__()
    self.url = url
    """
    A string that represents the path or url of the original file.
    """
    del self.GFXlist[0]
    self.width = self.height = 0
    self.append(url, frame, qty, direction, margin)

</t>
<t tx="leo.20181129171705.64">def _subframe(self, texture, frame):
    return GFX_Texture(texture, frame.GFX)
    
</t>
<t tx="leo.20181129171705.65">def append(self, url, frame=None, qty=1, direction='horizontal', margin=0):
    """
    Append a texture asset from a new image file (or url). This method
    allows you to build a collection of images into an asset (such as you
    might need for an animated sprite), but without using a single 
    sprite sheet image.

    The parameters for the `append` method are identical to those 
    supplied to the :class:`ImageAsset` initialization method. 

    This method allows you to build up an asset that consists of 
    multiple rows or columns of images in a sprite sheet or sheets.
    """
    GFX = GFX_Texture_fromImage(url, False)
    dx = 0
    dy = 0
    for i in range(qty):
        if not frame is None:
            self.width = frame.w
            self.height = frame.h
            if direction == 'horizontal':
                dx = frame.w + margin
            elif direction == 'vertical':
                dy = frame.h + margin
            f = Frame(frame.x + dx * i, frame.y + dy * i, frame.w, frame.h)
            GFX = self._subframe(GFX, f)
        else:
            self.width = GFX.width
            self.height = GFX.height
        self.GFXlist.append(GFX)


</t>
<t tx="leo.20181129171705.66">class Color(object):
    """
    The Color class is used to represent colors and/or colors with
    transparency.

    :param int color: an integer in the conventional format (usually 
        as a hexadecimal literal, e.g. 0xffbb33 that represents 
        the three color components, red, green and blue)
        
    :param float alpha: a transparency value, or `alpha` as a floating-point 
        number in the range of 0.0 to 1.0 where 0.0 represents 
        completely transparent and 1.0 represents completely opaque.
    
    Example::

        red = Color(0xff0000, 1.0)

    """
    _colornames = {
        0xffffff: 'white',
        0x000000: 'black'
    }
    
    @others
black = Color(0x000000, 1.0)
"""
Default black color
"""
white = Color(0xffffff, 1.0)
"""
Default white color
"""

</t>
<t tx="leo.20181129171705.67">def __init__(self, color, alpha):
    self.color = color
    self.alpha = alpha
    self.name = "Color(0x{0:06X}, {1})".format(int(self.color), self.alpha)
    if alpha == 1.0:
        self.name = self._colornames.get(self.color, self.name)
    
</t>
<t tx="leo.20181129171705.68">def __eq__(self, other):
    return type(self) is type(other) and self.color == other.color and self.alpha == other.alpha
    
</t>
<t tx="leo.20181129171705.69">def __repr__(self):
    return self.name

</t>
<t tx="leo.20181129171705.7">@others
if module_exists('PIL'):
  
  from PIL import Image

  class _body(object):
    
    def __init__(self):
      self.events = {}

    def appendChild(self, obj):
      self.child = obj

    def bind(self, evt, action):
      self.events[evt] = action
      print("Binding {} to {}".format(evt, action))
        
    def unbind(self, evt):
      print("Unbinding {}".format(evt))

  class _document(object):
    
    def __init__(self):
      self.body = _body()

  class _window(object):

    def __init__(self):
      self.document = _document()
      self.animatex = 0

    def open(self, s1, s2):
      return self

    def requestAnimationFrame(self, target):
      if self.animatex &lt; 10:
        self.animatex += 1
        target('dummy')
        print("Animation frame")

  class _Container(object):

    def __init__(self):
      self.things = []

    def destroy(self):
      del self.things

    def addChild(self, obj):
      self.things.append(obj)

    def removeChild(self, obj):
      self.things.remove(obj)

  class getBoundingClientRect(object):
    left = 0
    top = 0
    width = 1
    height = 1
  
  class renderView(object):
    def getBoundingClientRect(self):
      return getBoundingClientRect()

  class _Renderer(object):
    
    def __init__(self, x, y, argsdict):
      self.x = x
      self.y = y
      self.argsdict = argsdict
      self.view = renderView()
      print("Rendering created with {}x{} area".format(x, y))

    def render(self, stage):
      pass

  class _GFX(object):
    
    def __init__(self):
      self.Container = _Container
      self.autoDetectRenderer = _Renderer
      self.width = 0
      self.height = 0

  window = _window()

  GFX = _GFX()

  #document = object()
  
  def JSConstructor(cls):
    return cls
    
  def JSObject(obj):
    return obj
  
  class _GFX_Rectangle(object):

    def __init__(self, x, y, w, h):
      self.x = x
      self.y = y
      self.width = w
      self.height = h
  
  GFX_Rectangle = _GFX_Rectangle
 
  class _Texture(object):
 
    def __init__(self, img='', crossdomain=False):
      self.name = img
      self.crossdomain = crossdomain
      if img == '':
        self.img = None
        self.basewidth = 0
        self.baseheight = 0
        self.width = 0
        self.height = 0
      else:
        self.img = Image.open(img)
        self.basewidth = self.img.width
        self.baseheight = self.img.height
        self.width = self.basewidth
        self.height = self.baseheight
        print("Texture from image {}, {}x{} pixels".format(img, self.basewidth, self.baseheight))
      self.baserect = _GFX_Rectangle(0, 0, self.basewidth, self.baseheight)
      self.framerect = self.baserect  

    @classmethod
    def fromTexture(cls, texture, frame):
      inst = cls()
      inst.img = texture.img
      inst.name = texture.name
      inst.basewidth = texture.basewidth
      inst.baseheight = texture.baseheight
      inst.baserect = texture.baserect
      inst.framerect = frame
      inst.width = frame.width
      inst.height = frame.height
      print("Texture from base texture {}, {}x{} subframe {}x{}".format(inst.name, inst.basewidth, inst.baseheight, inst.framerect.width, inst.framerect.height))
      return inst

    def destroy(self):
      try:
        self.img.close()
        print("Destroying an image")
      except:
        print("Destroying a non-image")

  GFX_Texture = _Texture.fromTexture
  
  GFX_Texture_fromImage = _Texture  


  class vector(object):
  
    def __init__(self, x, y):
      self.x = x
      self.y = y

    def __getitem__(self, key):
      if key == 0:
        return self.x
      elif key == 1:
        return self.y
      else:
        raise KeyError

    def __setitem(self, key, value):
      if key == 0:
        self.x = value
      elif key == 1:
        self.y = value
      else:
        raise KeyError
  
  class GFX_Sprite(object):
    
    def __init__(self, texture):
      self.texture = texture
      self.visible = True
      self.pos = vector(0,0)
      self.anch = vector(0,0)
      self.scal = vector(1.0, 1.0)
      self.width = texture.width
      self.height = texture.height
      self.rotation = 0.0

    @property
    def position(self):
      return self.pos

    @position.setter
    def position(self, value):
      self.pos.x = value[0]
      self.pos.y = value[1]

    @property
    def anchor(self):
      return self.anch
 
    @anchor.setter
    def anchor(self, value):
      self.anch.x = value[0]
      self.anch.y = value[1]

    @property
    def scale(self):
      return self.scal

    @scale.setter
    def scale(self, value):
      self.scal.x = value[0]
      self.scal.y = value[1]

    def destroy(self):
      pass

  class _GFX_Graphics(object):

    def __init__(self):
      self.clear()

    def clear(self):
      self.cleared = True
      self.visible = True
      self.lwidth = None
      self.color = None
      self.alpha = None
      self.fillcolor = None
      self.fillalpha = None
      self.x = None
      self.y = None
      self.rwidth = None
      self.rheight = None
      self.radius = None
      self.ehw = None
      self.ehh = None
      self.xto = None
      self.yto = None
      self.jpath = None
      self.width = None
      self.height = None
      self.position = vector(0,0)

    def destroy(self):
      self.clear()

    def clone(self):
      clone = type(self)()
      clone.cleared = self.cleared
      clone.visible = self.visible
      clone.lwidth = self.lwidth
      clone.color = self.color
      clone.alpha = self.alpha
      clone.fillalpha = self.fillalpha
      clone.fillcolor = self.fillcolor
      clone.x = self.x
      clone.y = self.y
      clone.rwidth = self.rwidth
      clone.rheight = self.rheight
      clone.radius = self.radius
      clone.ehw = self.ehw
      clone.ehh = self.ehh
      clone.xto = self.xto
      clone.yto = self.yto
      clone.jpath = self.jpath
      clone.width = self.width
      clone.height = self.height
      clone.position = self.position
      return clone

    def lineStyle(self, width, color, alpha):
      self.width = width
      self.color = color
      self.alpha = alpha

    def beginFill(self, color, alpha):
      self.fillcolor = color
      self.fillalpha = alpha

    def drawRect(self, x, y, w, h):
      self.x = x
      self.y = y
      self.position = vector(x,y)
      self.rwidth = w
      self.rheight = h
      self.width = w
      self.height = h
      self.cleared = False
      print("Rectangle {}x{} at {},{}".format(w,h,x,y))
      return self

    def drawCircle(self, x, y, radius):
      self.x = x
      self.y = y
      self.position = vector(x,y)
      self.radius = radius
      self.cleared = False
      self.width = radius*2
      self.height = radius*2
      print("Circle, radius {} at {},{}".format(radius,x,y))
      return self  

    def drawEllipse(self, x, y, hw, hh):
      self.x = x
      self.y = y
      self.position = vector(x,y)
      self.ehw = hw
      self.ehh = hh
      self.width = hw*2
      self.height = hh*2
      self.cleared = False
      print("Ellipse, {}x{} at {},{}".format(hw,hh,x,y))
      return self

    def drawPolygon(self, jpath):
      self.jpath = jpath
      self.cleared = False
      self.position = vector(jpath[0],jpath[1])
      x = []
      y = []
      for i in range(0,len(jpath)-1,2):
        x.append(jpath[i])
        y.append(jpath[i+1])
      self.width = max(x)-min(x)
      self.height = max(y)-min(y)
      print("Polygon")
      return self

    def moveTo(self, x, y):
      self.x = x
      self.y = y
      self.position = vector(x,y)
      return self

    def lineTo(self, x, y):
      self.xto = x
      self.yto = y
      self.width = abs(x)
      self.height = abs(y)
      self.cleared = False
      print("Line from {},{} to {},{}".format(self.x, self.y, x, y))
      return self 

    def generateTexture(self):
        return _Texture()

  class _GFX_Text(object):

    def __init__(self, text, styledict):
      self.text = text
      self.styledict = styledict
      self.alpha = None
      self.visible = None
      self.width = 99
      self.height = 99
      self.position = vector(0,0)
      print("Text: {} in {}".format(text, styledict['font']))

    def clone(self):
      clone = type(self)(self.text, self.styledict)
      return clone

    def destroy(self):
      self.text = ''


  GFX_Text = _GFX_Text

  _globalGraphics = _GFX_Graphics()

  GFX_Graphics = _globalGraphics

  def GFX_DetectRenderer():
    pass
 
  class _SND_all(object):

    def __init__(self):
      pass

    def stop(self):
      print("Stopping all sounds")

  class _SND(object):
    
    def __init__(self):
      self.all = _SND_all

  SND = _SND()
  
  class _SND_Sound(object):

    def __init__(self, url):
      self.url = url
      print("Creating sound object {}".format(url))

    def load(self):
      pass

    def play(self):
      print("Playing sound object {}".format(self.url))

  SND_Sound = _SND_Sound

  
  class GFX_Window(object):
    
    def __init__(self, width, height, onclose):
      # 假如要執行時額外跳出一個視窗
      #self._w = window.open("", "")
      # 在原先的視窗中執行
      self._w = window
      self.width = width if width != 0 else 100
      self.height = height if height != 0 else 100
      self._stage = GFX.Container.new()
      self._renderer = GFX.autoDetectRenderer(width, height, {'transparent':True})
      self._w.document.body.appendChild(self._renderer.view)
      self._w.onunload = onclose
  
    def bind(self, evtspec, callback):
      self._w.document.body.bind(evtspec, callback)

    def unbind(self, evtspec):
      self._w.document.body.unbind(evtspec)         
      
    def add(self, obj):
      self._stage.addChild(obj)
      
    def remove(self, obj):
      self._stage.removeChild(obj)
      
    def animate(self, stepcallback):
      self._renderer.render(self._stage)
      self._w.requestAnimationFrame(stepcallback)
      
    def destroy(self):
      SND.all().stop()
      self._stage.destroy()
  
    
@language python
@tabwidth -4
@ignore
</t>
<t tx="leo.20181129171705.70">class LineStyle(object):
    """
    The LineStyle class is used to represent line style when
    drawing geometrical objects such as rectangles, ellipses, etc.

    :param int width: the `width` of the line in pixels
    
    :param Color color: the `color` as a valid :class:`Color` instance. 
    
    Example::

        line = LineStyle(3, Color(0x00ff00, 1.0))
        
    This defines a 3-pixel wide green line.
    """
    
    @others
blackline = LineStyle(1, black)
"""
Default thin black line
"""
whiteline = LineStyle(1, white)
"""
Default thin white line
"""

</t>
<t tx="leo.20181129171705.71">def __init__(self, width, color):
    """
    """
    self.width = width
    self.color = color

</t>
<t tx="leo.20181129171705.72">def __eq__(self, other):
    return type(self) is type(other) and self.width == other.width and self.color == other.color

</t>
<t tx="leo.20181129171705.73">def __repr__(self):
    return "LineStyle({}, {})".format(self.width, self.color)
    


</t>
<t tx="leo.20181129171705.74">class _GraphicsAsset(_Asset):
    
    @others
</t>
<t tx="leo.20181129171705.75">def __init__(self):
    super().__init__()
    GFX_Graphics.clear()
    

</t>
<t tx="leo.20181129171705.76">class _CurveAsset(_GraphicsAsset):

    @others
</t>
<t tx="leo.20181129171705.77">def __init__(self, line):
    super().__init__()
    GFX_Graphics.lineStyle(line.width, line.color.color, line.color.alpha)

</t>
<t tx="leo.20181129171705.78">class _ShapeAsset(_CurveAsset):

    @others
</t>
<t tx="leo.20181129171705.79">def __init__(self, line, fill):
    super().__init__(line)
    GFX_Graphics.beginFill(fill.color, fill.alpha)


</t>
<t tx="leo.20181129171705.8">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.80">class RectangleAsset(_ShapeAsset):
    """
    The RectangleAsset is a "virtual" asset that is created on the
    fly without requiring creation of an image file.

    :param int width: Rectangle width, in pixels
    :param int height: Rectangle height, in pixels
    :param LineStyle line=blackline: The color and width of the rectangle border
    :param Color fill=black: The color of the rectangle body
    """

    @others
</t>
<t tx="leo.20181129171705.81">def __init__(self, width, height, line=blackline, fill=black):
    super().__init__(line, fill)
    self.width = width
    self.height = height
    self.GFX = GFX_Graphics.drawRect(0, 0, self.width, self.height).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False
    

</t>
<t tx="leo.20181129171705.82">class CircleAsset(_ShapeAsset):
    """
    The `ggame.CircleAsset` is a "virtual" asset that is created on the
    fly without requiring creation of an image file.

    :param int radius: Circle radius, in pixels
    :param LineStyle line=blackline: The color and width of the circle border
    :param Color fill=black: The color of the circle body
    """    

    @others
</t>
<t tx="leo.20181129171705.83">def __init__(self, radius, line=blackline, fill=black):
    super().__init__(line, fill)
    self.radius = radius
    self.GFX = GFX_Graphics.drawCircle(0, 0, self.radius).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False
    
</t>
<t tx="leo.20181129171705.84">class EllipseAsset(_ShapeAsset):
    """
    The `ggame.EllipseAsset` is a "virtual" asset that is created on the 
    fly without requiring creation of an image file.

    :param int halfw: Ellipse semi-axis dimension in the horizontal direction
        (half the width of the ellipse), in pixels
    :param int halfh: Ellipse semi-axis dimension in the vertical direction
        (half the height of the ellipse), in pixels
    :param LineStyle line=blackline: The color and width of the ellipse border
    :param Color fill=black: The color of the ellipse body

    """

    @others
</t>
<t tx="leo.20181129171705.85">def __init__(self, halfw, halfh, line=blackline, fill=black):
    super().__init__(line, fill)
    self.halfw = halfw
    self.halfh = halfh
    self.GFX = GFX_Graphics.drawEllipse(0, 0, self.halfw, self.halfh).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False
    
</t>
<t tx="leo.20181129171705.86">class PolygonAsset(_ShapeAsset):
    """
    The PolygonAsset is a "virtual" asset that is created on the
    fly without requiring creation of an image file.
    
    Note: you should not specificy absolute screen coordinates for this
    asset, since you will use the :class:`Sprite` position to locate your 
    polygon on the screen.

    :param list path: A list of pixel-coordinate tuples. These coordinates should 
        not be in absolute screen coordinates, but should be relative to the
        desired 'center' of the resulting :class:`Sprite`. The final 
        coordinate pair in the list must be the same as the first.
    :param LineStyle line=blackline: The color and width of the ellipse border
    :param Color fill=black: The color of the ellipse body
        
    Example::
    
        poly = PolygonAsset([(0,0), (50,50), (50,100), (0,0)], 
            LineStyle(4, black), 
            Color(0x80FF00, 0.8)))

    """

    @others
</t>
<t tx="leo.20181129171705.87">def __init__(self, path, line=blackline, fill=black):
    super().__init__(line, fill)
    self.path = path
    jpath = []
    for point in self.path:
        jpath.extend(point)
    self.GFX = GFX_Graphics.drawPolygon(jpath).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False


</t>
<t tx="leo.20181129171705.88">class LineAsset(_CurveAsset):
    """
    The LineAsset is a "virtual" asset that is created on the
    fly without requiring creation of an image file. A LineAsset instance
    represents a single line segment.

    Note: you should not specificy absolute screen coordinates for this
    asset, since you will use the :class:`Sprite` position to locate your 
    line on the screen. The line segment will begin at pixel coordinates (0,0),
    and will end at the (x,y) coordinates given below.

    As the LineAsset does not cover a region, only a :class:`LineStyle` 
    argument must be supplied (`line`) to specify the color.

    :param int x: x-coordinate of the line endpoint, in pixel units
    :param int y: y-coordinate of the line endpoint, in pixel units
    :param LineStyle line=blackline: The color and width of the ellipse border
    """

    @others
</t>
<t tx="leo.20181129171705.89">def __init__(self, x, y, line=blackline):
    super().__init__(line)
    self.deltaX = x
    """This attribute represents the `x` parameter supplied during instantiation."""
    self.deltaY = y
    """This attribute represents the `y` parameter supplied during instantiation."""
    GFX_Graphics.moveTo(0, 0)
    self.GFX = GFX_Graphics.lineTo(self.deltaX, self.deltaY).clone()
    """The `GFX` property represents the underlying system object."""
    self.GFX.visible = False

</t>
<t tx="leo.20181129171705.9">@others
@language python
@tabwidth -4
</t>
<t tx="leo.20181129171705.90">class TextAsset(_GraphicsAsset):
    """
    The TextAsset is a "virtual" asset that is created on the fly
    without requiring creation of an image file. A TextAsset instance
    represents a block of text, together with its styling (font, color, etc.).

    :param str text: The text that should be displayed

    :param \**kwargs: Optional formatting and style attributes (below)
    
    :param str style='20px Arial': Text style, size and typeface. Example:: 
    
            'italic 20pt Helvetica'
        
    :keyword int width=100: Width of the text block on screen, in pixels. 
    :param Color fill=black: :class:`Color` instance to specify color
        and transparency of the text. 
    :param str align='left': Alignment style of the block. One of 'left',
        'center', or 'right'. 

    Full example::
    
        ta = TextAsset("Sample Text", 
            style="bold 40pt Arial", 
            width=250, 
            fill=Color(0x1122ff, 1.0))

    """
 
    @others
</t>
<t tx="leo.20181129171705.91">def __init__(self, text, **kwargs):
    """
    """
    super().__init__()
    self.text = text
    self.style = kwargs.get('style', '20px Arial')
    width = kwargs.get('width', 100)
    self.fill = kwargs.get('fill', Color(0, 1))
    self.align = kwargs.get('align', 'left')
    self.GFX = GFX_Text(self.text, 
        {'font': self.style,
            'fill' : self.fill.color,
            'align' : self.align,
            'wordWrap' : True,
            'wordWrapWidth' : width,
            })
    self.GFX.alpha = self.fill.alpha
    self.GFX.visible = False
    
</t>
<t tx="leo.20181129171705.92">def _clone(self):
    return type(self)(self.text,
        style = self.style,
        width = self.width,
        fill = self.fill,
        align = self.align)

</t>
<t tx="leo.20181129171705.93">@property
def width(self):
    return self.GFX.width
    
</t>
<t tx="leo.20181129171705.94">@property
def height(self):
    return self.GFX.height

</t>
<t tx="leo.20181129171705.95">"""
ggame extensions for modeling spacecraft in planetary orbit
"""

from math import pi, degrees, radians, atan2, sin, cos, sqrt
from ggame.asset import LineStyle, Color
from ggame.mathapp import MathApp
from ggame.circle import Circle
from ggame.point import ImagePoint
from ggame.timer import Timer
from ggame.label import Label

</t>
<t tx="leo.20181129171705.96">class Rocket(ImagePoint):
    """
    Rocket is a class for simulating the motion of a projectile through space, 
    acted upon by arbitrary forces (thrust) and by gravitaitonal 
    attraction to a single planetary object.

    Initialize the Rocket object. 
    
    Example:
    
        rocket1 = Rocket(earth, altitude=400000, velocity=7670, timezoom=2)
   
    Required parameters:
    
    * **planet**:  Reference to a `Planet` object.
    
    Optional keyword parameters are supported:
    
    * **bitmap**:  url of a suitable bitmap image for the rocket (png recommended)
      default is `ggimages/rocket.png`
    * **bitmapscale**:  scale factor for bitmap. Default is 0.1
    * **velocity**:  initial rocket speed. default is zero.
    * **directiond**:  initial rocket direction in degrees. Default is zero.
    * **direction**:  initial rocket direction in radians. Default is zero.
    * **tanomalyd**:  initial rocket true anomaly in degrees. Default is 90.
    * **tanomaly**:  initial rocket true anomaly in radians. Default is pi/2.
    * **altitude**:  initial rocket altitude in meters. Default is zero.
    * **showstatus**:  boolean displays flight parameters on screen. Default
      is True.
    * **statuspos**:  tuple with x,y coordinates of flight parameters. 
      Default is upper left.
    * **statuslist**: list of status names to include in flight parameters. 
      Default is all, consisting of: "velocity", "acceleration", "course",
      "altitude", "thrust", "mass", "trueanomaly", "scale", "timezoom",
      "shiptime"
    * **leftkey**: a `ggame` key identifier that will serve as the 
      "rotate left" key while controlling the ship. Default is 'left arrow'.
    * **rightkey**: a `ggame` key identifier that will serve as the 
      "rotate right" key while controlling the ship. Default is 'right arrow'.
    
    Following parameters may be set as a constant value, or pass in the
    name of a function that will return the value dynamically or the
    name of a `ggmath` UI control that will return the value.
    
    * **timezoom**  scale factor for time zoom. Factor = 10^timezoom
    * **heading**  direction to point the rocket in (must be radians)
    * **mass**  mass of the rocket (must be kg)
    * **thrust**  thrust of the rocket (must be N)

    Animation related parameters may be ignored if no sprite animation:
    
    * **bitmapframe**  ((x1,y1),(x2,y2)) tuple defines a region in the bitmap
    * **bitmapqty**  number of bitmaps -- used for animation effects
    * **bitmapdir**  "horizontal" or "vertical" use with animation effects
    * **bitmapmargin**  pixels between successive animation frames
    * **tickrate**  frequency of spacecraft dynamics calculations (Hz)
    
    """

    @others
</t>
<t tx="leo.20181129171705.97">def __init__(self, planet, **kwargs):
    self._xy = (1000000,1000000)
    self.planet = planet
    self.bmurl = kwargs.get('bitmap', 'ggimages/rocket.png') # default rocket png
    self.bitmapframe = kwargs.get('bitmapframe', None) #
    self.bitmapqty = kwargs.get('bitmapqty', 1) # Number of images in bitmap
    self.bitmapdir = kwargs.get('bitmapdir', 'horizontal') # animation orientation
    self.bitmapmargin = kwargs.get('bitmapmargin', 0) # bitmap spacing
    self.tickrate = kwargs.get('tickrate', 30) # dynamics calcs per sec
    # status display
    statusfuncs = [ self.velocityText,
                    self.accelerationText,
                    self.courseDegreesText,
                    self.altitudeText,
                    self.thrustText,
                    self.massText,
                    self.trueAnomalyDegreesText,
                    self.scaleText,
                    self.timeZoomText,
                    self.shipTimeText]
    statuslist = [  "velocity",
                    "acceleration",
                    "course",
                    "altitude",
                    "thrust",
                    "mass",
                    "trueanomaly",
                    "scale",
                    "timezoom",
                    "shiptime"]
    
    self.showstatus = kwargs.get('showstatus', True) # show stats
    self.statuspos = kwargs.get('statuspos', [10,10])  # position of stats
    self.statusselect = kwargs.get('statuslist', statuslist)
    self.localheading = 0
    # dynamic parameters
    self.timezoom = self.Eval(kwargs.get('timezoom', self.gettimezoom)) # 1,2,3 faster, -1, slower
    self.heading = self.Eval(kwargs.get('heading', self.getheading)) # must be radians
    self.mass = self.Eval(kwargs.get('mass', self.getmass)) # kg
    self.thrust = self.Eval(kwargs.get('thrust', self.getthrust)) # N
    # end dynamic 
    super().__init__(self.bmurl,
        self._getposition, 
        frame = self.bitmapframe, 
        qty = self.bitmapqty, 
        direction = self.bitmapdir,
        margin = self.bitmapmargin)
    self.scale = kwargs.get('bitmapscale', 0.1) # small
    initvel = kwargs.get('velocity', 0) # initial velocity
    initdird = kwargs.get('directiond', 0) # initial direction, degrees
    initdir = kwargs.get('direction', radians(initdird))
    tanomaly = kwargs.get('tanomaly', pi/2) # position angle
    tanomaly = radians(kwargs.get('tanomalyd', degrees(tanomaly))) 
    altitude = kwargs.get('altitude', 0) #
    r = altitude + self.planet.radius
    self._xy = (r*cos(tanomaly), r*sin(tanomaly))
    # default heading control if none provided by user
    leftkey = kwargs.get('leftkey', 'left arrow')
    rightkey = kwargs.get('rightkey', 'right arrow')
    if self.heading == self.getheading:
        Planet.listenKeyEvent('keydown', leftkey, self.turn)
        Planet.listenKeyEvent('keydown', rightkey, self.turn)
    self.timer = Timer()
    self.shiptime = 0  # track time on shipboard
    self.timer.callEvery(1/self.tickrate, self.dynamics)
    self.lasttime = self.timer.time
    self.V = [initvel * cos(initdir), initvel * sin(initdir)]
    self.A = [0,0]
    # keep track of on-screen resources
    self._labels = []
    # set up status display
    if self.showstatus:
        self.addStatusReport(statuslist, statusfuncs, self.statusselect)

# override or define externally!
</t>
<t tx="leo.20181129171705.98">def getthrust(self):
    """
    User override function for dynamically determining thrust force.
    """
    return 0

# override or define externally!
</t>
<t tx="leo.20181129171705.99">def getmass(self):
    """
    User override function for dynamically determining rocket mass.
    """
    return 1

# override or define externally!
</t>
<t tx="leo.20181129171706.1">"""
ggame events are objects that are created by the ggame system as a result of 
some user action (mouse, keyboard). If the ggame application has called
:meth:`~ggame.app.App.listenKeyEvent` or :meth:`~ggame.app.App.listenMouseEvent` then
an appropriate Event object is instantiated by ggame and returned to a 
user-provided handler function. The ggame user code should examine the 
attributes of the Event object to find out more information about the event that
occurred.
"""

</t>
<t tx="leo.20181129171706.10">class ImageIndicator(_MathVisual):

    _posinputsdef = ['pos']
    _nonposinputsdef = ['value']

    @others
</t>
<t tx="leo.20181129171706.100">def _handleMouseUp(self, event):
    if self.mouseDownObject:
        self.mouseDownObject.mouseup()
        self.mouseDownObject = None
    self.mouseDown = False
    self.mouseCapturedObject = None
    self.mouseStrokedObject = None

</t>
<t tx="leo.20181129171706.101">def _handleMouseMove(self, event):
    if not self.mouseX:
        self.mouseX = event.x
        self.mouseY = event.y
    dx = event.x - self.mouseX
    dy = event.y - self.mouseY
    self.mouseX = event.x
    self.mouseY = event.y
    if self.mouseDown:
        if self.mouseCapturedObject:
            self.mouseCapturedObject.translate((dx, dy))
        elif self.mouseStrokedObject:
            self.mouseStrokedObject.stroke((self.mouseX,self.mouseY), (dx,dy))
        else:
            lmove = self.translatePhysicalToLogical((dx, dy))
            MathApp._xcenter -= lmove[0]
            MathApp._ycenter -= lmove[1]
            self._touchAllVisuals()
            self._viewNotify("translate")

</t>
<t tx="leo.20181129171706.102">def _handleMouseWheel(self, event):
    zoomfactor = event.wheelDelta/100
    zoomfactor = 1+zoomfactor if zoomfactor &gt; 0 else 1+zoomfactor
    if zoomfactor &gt; 1.2:
        zoomfactor = 1.2
    elif zoomfactor &lt; 0.8:
        zoomfactor = 0.8
    MathApp._scale *= zoomfactor
    self._touchAllVisuals()
    self._viewNotify("zoom")
    
</t>
<t tx="leo.20181129171706.103">@property
def viewPosition(self):
    """
    Attribute is used to get or set the current logical coordinates 
    at the center of the screen as a tuple of floats (x,y).
    """
    return (MathApp._xcenter, MathApp._ycenter)
    
</t>
<t tx="leo.20181129171706.11">def __init__(self, url, *args, **kwargs):
    """
    Required Inputs
    
    * **url** location of image file consisting of two image sprite sheet
    * **pos** position of point
    * **value** state of the indicator (True/False or integer)

    Optional Inputs
    * **frame** sub-frame location of image within file
    * **qty** number of sub-frames, when used as sprite sheet
    * **direction** one of 'horizontal' (default) or 'vertical'
    * **margin** pixels between sub-frames if sprite sheet
    """
    kwargs.setdefault('frame', None)
    kwargs.setdefault('qty', 1)
    kwargs.setdefault('direction', 'horizontal')
    kwargs.setdefault('margin', 0)
    super().__init__(
        ImageAsset(url, 
            kwargs['frame'], 
            kwargs['qty'], 
            kwargs['direction'], 
            kwargs['margin']), 
        *args, **kwargs)
    self.center = (0,0)

</t>
<t tx="leo.20181129171706.12">def _buildAsset(self):
    inval = self._nposinputs.value()
    if inval == True:
        self.setImage(1)
    elif inval == False:
        self.setImage(0)
    else:
        self.setImage(inval)
    return self.asset

</t>
<t tx="leo.20181129171706.13">def physicalPointTouching(self, ppos):
    self._setExtents()  # ensure xmin, xmax are correct
    x, y = ppos
    return x &gt;= self.xmin and x &lt; self.xmax and y &gt;= self.ymin and y &lt;= self.ymax

</t>
<t tx="leo.20181129171706.14">def translate(self, pdisp):
    pass


</t>
<t tx="leo.20181129171706.15">class LEDIndicator(ImageIndicator):
    
    @others
</t>
<t tx="leo.20181129171706.16">def __init__(self, *args, **kwargs):
    """
    Required Inputs
    
    * **pos** position of point
    * **value** state of the indicator (True/False or integer)

    """
    kwargs.setdefault('frame', Frame(0,0,600,600))
    kwargs.setdefault('qty', 2)
    super().__init__("ggimages/red-led-off-on.png", *args, **kwargs)
    self.scale = 0.05
</t>
<t tx="leo.20181129171706.17">from ggame.label import Label
from ggame.asset import TextAsset
from ggame.mathapp import MathApp

</t>
<t tx="leo.20181129171706.18">class InputNumeric(Label):
    """
    Create a :class:`~ggame.label.Label` that can be selected to accept
    new **numeric** input from the keyboard. This is a 
    subclass of :class:`~ggame.sprite.Sprite` and 
    :class:`~ggame.mathapp._MathVisual` but most of the inherited 
    members are of little use and are not shown in the documentation. 

    :param tuple(float,float) pos: Screen position of the control, which may
            be a literal tuple of floats, or a reference to any object or 
            function that returns or evaluates to a tuple of floats.
            
    :param float val: Initial value of the input text

    :param \**kwargs:
        See below

    :Optional Keyword Arguments:
        * **fmt** (*str*) a Python format string (default is {0:.2f})
        * **positioning** (*str*) One of 'logical' or 'physical'
        * **size** (*int*) Size of text font (in pixels)
        * **width** (*int*) Width of the label (in pixels)
        * **color** (*Color*) Valid :class:`~ggame.asset.Color` object
        
    Example::
    
        from ggame.input import InputNumeric
        from ggame.mathapp import MathApp
        
        p = InputNumeric(
            (300, 275),     # screen coordinates of input
            3.14,           # initial value
            positioning="physical") # use physical coordinates

        MathApp().run()
    """
    
    @others
</t>
<t tx="leo.20181129171706.19">def __init__(self, pos, val, **kwargs):
    self._fmt = kwargs.get('fmt', '{0:.2f}')
    self._val = self.Eval(val)()  # initialize to simple numeric
    self._savedval = self._val
    self._updateText()
    super().__init__(pos, self._textValue, **kwargs)
    self.selectable = True
    
</t>
<t tx="leo.20181129171706.2">class _Event(object):

    @others
</t>
<t tx="leo.20181129171706.20">def _textValue(self):
    return self._text()

</t>
<t tx="leo.20181129171706.21">def _updateText(self):
    self._text = self.Eval(self._fmt.format(self._val))

</t>
<t tx="leo.20181129171706.22">def processEvent(self, event):
    if event.key in "0123456789insertdelete":
        key = event.key
        if event.key == 'insert':
            key = '-'
        elif event.key == 'delete':
            key = '.'
        if self._text() == "0":
            self._text = self.Eval("")
        self._text = self.Eval(self._text() + key)
        self._touchAsset()
    elif event.key in ['enter','escape']:
        if event.key == 'enter':
            try:
                self._val = float(self._text())
            except ValueError:
                self._val = self._savedval
            self._savedval = self._val
        self.unselect()
        

</t>
<t tx="leo.20181129171706.23">def select(self):
    super().select()
    self._savedval = self._val
    self._val = 0
    self._updateText()
    self._touchAsset()
    MathApp.listenKeyEvent("keypress", "*", self.processEvent)

</t>
<t tx="leo.20181129171706.24">def unselect(self):
    super().unselect()
    self._val = self._savedval
    self._updateText()
    self._touchAsset()
    try:
        MathApp.unlistenKeyEvent("keypress", "*", self.processEvent)
    except ValueError:
        pass

</t>
<t tx="leo.20181129171706.25">def __call__(self):
    return self._val


</t>
<t tx="leo.20181129171706.26">class InputButton(Label):
    """
    Create a :class:`~ggame.label.Label` that can be clicked with a mouse
    to execute a user-defined function. This is a 
    subclass of :class:`~ggame.sprite.Sprite` and 
    :class:`~ggame.mathapp._MathVisual` but most of the inherited 
    members are of little use and are not shown in the documentation. 

    :param function callback: A reference to a function to execute, passing 
        this button object, when the button is clicked
    :param tuple(float,float) pos: Screen position of the control, which may
            be a literal tuple of floats, or a reference to any object or 
            function that returns or evaluates to a tuple of floats.
            
    :param float val: Initial value of the input text

    :param \*args:
        See below
    :param \**kwargs:
        See below

    :Required Arguments:
        * **pos**  (*tuple(float,float)*) Screen position of the button, which may
            be a literal tuple of floats, or a reference to any object or 
            function that returns or evaluates to a tuple of floats.
        * **text** (*str*) Text to appear in the button. This may be a literal
            string or a reference to any object or function that returns or
            evaluates to a string.


    :Optional Keyword Arguments:
        * **positioning** (*str*) One of 'logical' or 'physical'
        * **size** (*int*) Size of text font (in pixels)
        * **width** (*int*) Width of the label (in pixels)
        * **color** (*Color*) Valid :class:`~ggame.asset.Color` object
        
    Example::
    
        from ggame.asset import Color
        from ggame.label import InputButton
        from ggame.mathapp import MathApp
    
        def pressbutton(buttonobj):
            print("InputButton pressed!")
    
        InputButton(
            pressbutton,            # reference to handler
            (20,80),                # physical location on screen
            "Press Me",             # text to display
            size=15,                # text size (pixels)
            positioning="physical") # use physical coordinates

        MathApp().run()
    """
    
    @others
</t>
<t tx="leo.20181129171706.27">def __init__(self, callback, *args,  **kwargs):
    """
    Required Inputs
    
    * **pos** position of button
    * **text** text of button
    * **callback** reference of a function to execute, passing this button object
    """
    super().__init__(*args, **kwargs)
    self._touchAsset()
    self._callback = callback
    self.selectable = True

</t>
<t tx="leo.20181129171706.28">def _buildAsset(self):
    return TextAsset(self._nposinputs.text(), 
                        style="bold {0}px Courier".format(self._stdinputs.size()),
                        width=self._stdinputs.width(),
                        fill=self._stdinputs.color())

</t>
<t tx="leo.20181129171706.29">def select(self):
    super().select()
    if self._callback: self._callback(self)
    self.unselect()

</t>
<t tx="leo.20181129171706.3">def __init__(self, hwevent):
    self.hwevent = hwevent
    self.type = hwevent.type
    """String representing the type of received system event."""
    self.consumed = False
    """
    Set the `consumed` member of the event to prevent the event
    from being received by any more handler methods.
    """
    
</t>
<t tx="leo.20181129171706.30">def unselect(self):
    super().unselect()

</t>
<t tx="leo.20181129171706.31">from ggame.point import ImagePoint
from ggame.asset import Frame

</t>
<t tx="leo.20181129171706.32">class InputImageButton(ImagePoint):
    
    @others
</t>
<t tx="leo.20181129171706.33">def __init__(self, url, callback, *args, **kwargs):
    """
    Required Inputs
    
    * **url** location of image file
    * **callback** reference of a function to execute, passing this button object
    * **pos** position of point
    
    Optional Inputs
    * **frame** sub-frame location of image within file
    * **qty** number of sub-frames, when used as sprite sheet
    * **direction** one of 'horizontal' (default) or 'vertical'
    * **margin** pixels between sub-frames if sprite sheet
    """
    super().__init__(url, *args, **kwargs)
    self.center = (0,0)
    self._callback = callback
    self.selectable = True
    self.firstImage()
    self.mousewasdown = self.mouseisdown

</t>
<t tx="leo.20181129171706.34">def select(self):
    super().select()
    if self._callback: self._callback(self)
    self.unselect()

</t>
<t tx="leo.20181129171706.35">def unselect(self):
    super().unselect()

</t>
<t tx="leo.20181129171706.36">def __call__(self):
    # code for controlling the button image state only works if the
    # button state is being monitored!
    if self.mouseisdown != self.mousewasdown:
        if self.mouseisdown:
            self.nextImage()
        else:
            self.firstImage()
        self.mousewasdown = self.mouseisdown
    return self.mouseisdown
    

</t>
<t tx="leo.20181129171706.37">class InputImageToggle(ImagePoint):

    @others
</t>
<t tx="leo.20181129171706.38">def __init__(self, url, statelist, initindex, *args, **kwargs):
    """
    Required Inputs
    
    * **url** location of image file
    * **statelist** list of values to correspond with toggle states
    * **initindex** index to initial toggle state
    * **pos** position of point
    
    Optional Inputs
    * **frame** sub-frame location of image within file
    * **direction** for sprite sheet one of 'horizontal' (default) or 'vertical'
    * **margin** pixels between sub-frames if sprite sheet
    * Note the qty of images is equal to length of the statelist
    """
    self.statelist = statelist
    kwargs.setdefault('qty', len(statelist))
    super().__init__(url, *args, **kwargs)
    self.center = (0,0)
    self.selectable = True
    self.togglestate = initindex
    self.setImage(self.togglestate)

</t>
<t tx="leo.20181129171706.39">def select(self):
    super().select()
    self.togglestate += 1
    if self.togglestate == len(self.statelist):
        self.togglestate = 0
    self.setImage(self.togglestate)
    self.unselect()

</t>
<t tx="leo.20181129171706.4">class MouseEvent(_Event):
    """
    A MouseEvent object encapsulates information about a user mouse
    action that is being reported by the system.  This class is not instantiated
    by the ggame user.
    """    

    mousemove = "mousemove"
    mousedown = "mousedown"
    mouseup = "mouseup"
    click = "click"
    dblclick = "dblclick"
    mousewheel = "wheel"

    @others
</t>
<t tx="leo.20181129171706.40">def __call__(self):
    return self.statelist[self.togglestate]


</t>
<t tx="leo.20181129171706.41">class MetalToggle(InputImageToggle):
    @others
</t>
<t tx="leo.20181129171706.42">def __init__(self, initindex, *args, **kwargs):
    """
    Required Inputs
    
    * **initindex** index to initial toggle state
    * **pos** position of toggle
    """
    kwargs.setdefault('frame', Frame(0,0,110,150))
    super().__init__("ggimages/toggle-up-down.png", [True, False], initindex, *args, **kwargs)
    self.scale = 0.4
    


</t>
<t tx="leo.20181129171706.43">class GlassButton(InputImageButton):
    
    @others
</t>
<t tx="leo.20181129171706.44">def __init__(self, callback, *args, **kwargs):
    """
    Required Inputs
    
    * **callback** reference of a function to execute, passing this button object
    * **pos** position of point
    """        
    kwargs.setdefault('frame', Frame(0,0,100,100))
    kwargs.setdefault('qty', 2)
    super().__init__("ggimages/button-round.png", callback, *args, **kwargs)
    self.scale = 0.3
</t>
<t tx="leo.20181129171706.45">from ggame.mathapp import _MathVisual
from ggame.asset import TextAsset

</t>
<t tx="leo.20181129171706.46">class Label(_MathVisual):
    """
    Create a text label on the screen. This is a 
    subclass of :class:`~ggame.sprite.Sprite` and 
    :class:`~ggame.mathapp._MathVisual` but most of the inherited 
    members are of little use and are not shown in the documentation. 

    :param \*args:
        See below
    :param \**kwargs:
        See below

    :Required Arguments:
        * **pos**  (*tuple(float,float)*) Screen position of the label, which may
            be a literal tuple of floats, or a reference to any object or 
            function that returns or evaluates to a tuple of floats.
        * **text** (*str*) Text to appear in the label. This may be a literal
            string or a reference to any object or function that returns or
            evaluates to a string.

    :Optional Keyword Arguments:
        * **positioning** (*str*) One of 'logical' or 'physical'
        * **size** (*int*) Size of text font (in pixels)
        * **width** (*int*) Width of the label (in pixels)
        * **color** (*Color*) Valid :class:`~ggame.asset.Color` object

    
    Example::
    
        from ggame.asset import Color
        from ggame.label import Label
        from ggame.mathapp import MathApp
    
        Label(
            (20,80),                # physical location on screen
            "Initial Speed (m/s)",  # text to display
            size=15,                # text size (pixels)
            positioning="physical", # use physical coordinates
            color=Color(0x202000, 1.0)) # text color
            
        MathApp().run()
    """
    
    _posinputsdef = ['pos']
    _nonposinputsdef = ['text']
    
    @others
</t>
<t tx="leo.20181129171706.47">def __init__(self, *args, **kwargs):
    """
    Required Inputs
    
    * **pos** position of label
    * **text** text contents of label
    """
    super().__init__(TextAsset(""), *args, **kwargs)
    self._touchAsset()

</t>
<t tx="leo.20181129171706.48">def _buildAsset(self):
    return TextAsset(self._nposinputs.text(), 
                        style="{0}px Courier".format(self._stdinputs.size()),
                        width=self._stdinputs.width(),
                        fill=self._stdinputs.color())

</t>
<t tx="leo.20181129171706.49">def __call__(self):
    return self._nposinputs.text()

</t>
<t tx="leo.20181129171706.5">def __init__(self, appclass, hwevent):
    """
    The event is initialized by the system, with a `hwevent` input parameter.
    """
    super().__init__(hwevent)
    self.wheelDelta = 0
    """Integer representing up/down motion of the scroll wheel."""
    if self.type == self.mousewheel:
        self.wheelDelta = hwevent.deltaY
    else:
        self.wheelDelta = 0
    rect = appclass._win._renderer.view.getBoundingClientRect()
    xscale = appclass._win.width/rect.width
    yscale = appclass._win.height/rect.height
    self.x = (hwevent.clientX - rect.left) * xscale
    """The window x-coordinate of the mouse pointer when the event occurred."""
    self.y = (hwevent.clientY - rect.top) * yscale
    """The window y-coordinate of the mouse pointer when the event occurred."""


</t>
<t tx="leo.20181129171706.50">def physicalPointTouching(self, ppos):
    _ppos = self._spposinputs.pos
    return (ppos[0] &gt;= _ppos[0] and 
        ppos[0] &lt;= _ppos[0] + self._sstdinputs.width and
        ppos[1] &gt;= _ppos[1] and 
        ppos[1] &lt;= _ppos[1] + self._sstdinputs.size)

</t>
<t tx="leo.20181129171706.51">def translate(self, pdisp):
    pass
</t>
<t tx="leo.20181129171706.52">from ggame.mathapp import _MathVisual
from ggame.asset import LineAsset


</t>
<t tx="leo.20181129171706.53">class LineSegment(_MathVisual):
    """
    Create a line segment on the screen. This is a subclass of 
    :class:`~ggame.sprite.Sprite` and 
    :class:`~ggame.mathapp._MathVisual` but most of the inherited members are of
    little use and are not shown in the documentation.


    :param \*args:
        See below
    :param \**kwargs:
        See below
        
    :Required Arguments:
        * **pos** (*tuple(float,float)*) Starting point of the segment, which may
            be a literal tuple of floats, or a reference to any object or 
            function that returns or evaluates to a tuple of floats.
        * **end** (*tuple(float,float)*) Ending point of the segment (see above)
    

    :Optional Keyword Arguments:
        * **positioning** (*str*) One of 'logical' or 'physical'
        * **style** (*LineStyle*) Valid :class:`~ggame.asset.LineStyle` object
        
    Example::
        
        from ggame.point import Point
        from ggame.line import LineSegment
        from ggame.mathapp import MathApp
        
        p1 = Point((2,1))
        ls = LineSegment(p1, Point((1,1)))
        
        MathApp().run()
    """
    
    _posinputsdef = ['pos','end']
    
    @others
</t>
<t tx="leo.20181129171706.54">def __init__(self, *args, **kwargs):
    super().__init__(LineAsset(0,0, self._defaultstyle), *args, **kwargs)
    self._touchAsset()
    
</t>
<t tx="leo.20181129171706.55">def _buildAsset(self):
    start = self._pposinputs.pos
    end = self._pposinputs.end
    self.position = start
    return LineAsset(end[0]-start[0],
                        end[1]-start[1],
                        self._stdinputs.style())

</t>
<t tx="leo.20181129171706.56">def physicalPointTouching(self, ppos):
    """
    This method always returns False.
    """
    return False

</t>
<t tx="leo.20181129171706.57">def translate(self, pdisp):
    """
    This method is not implemented.
    """
    pass

</t>
<t tx="leo.20181129171706.58">"""
These digital logic classes are experimental.
"""

from ggame.mathapp import MathApp, _MathDynamic
from abc import ABCMeta, abstractmethod


# decorator for _getvalue or any value handler that may experience recursion
</t>
<t tx="leo.20181129171706.59">def _recursiontrap(handler):
    def trapmagic(self):
        if not self.ingetvalue:
            self.ingetvalue = True
            self.lastget = handler(self)
            self.ingetvalue = False
            return self.lastget
        else:
            self.ingetvalue = False
            return self.lastget
            
    return trapmagic 


</t>
<t tx="leo.20181129171706.6">class KeyEvent(_Event):
    """
    A KeyEvent object encapsulates information regarding a user keyboard
    action that is being reported by the system. This class is not instantiated
    by the ggame user.
    """    

    no_location = 0
    right_location = 2
    left_location = 1
    keydown = "keydown"
    keyup = "keyup"
    keypress = "keypress"
    keys = {8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        19: 'pause/break',
        20: 'caps lock',
        27: 'escape',
        32: 'space',
        33: 'page up',
        34: 'page down',
        35: 'end',
        36: 'home',
        37: 'left arrow',
        38: 'up arrow',
        39: 'right arrow',
        40: 'down arrow',
        45: 'insert',
        46: 'delete',
        48: '0',
        49: '1',
        50: '2',
        51: '3',
        52: '4',
        53: '5',
        54: '6',
        55: '7',
        56: '8',
        57: '9',
        65: 'a',
        66: 'b',
        67: 'c',
        68: 'd',
        69: 'e',
        70: 'f',
        71: 'g',
        72: 'h',
        73: 'i',
        74: 'j',
        75: 'k',
        76: 'l',
        77: 'm',
        78: 'n',
        79: 'o',
        80: 'p',
        81: 'q',
        82: 'r',
        83: 's',
        84: 't',
        85: 'u',
        86: 'v',
        87: 'w',
        88: 'x',
        89: 'y',
        90: 'z',
        91: 'left window key',
        92: 'right window key',
        93: 'select key',
        96: 'numpad 0',
        97: 'numpad 1',
        98: 'numpad 2',
        99: 'numpad 3',
        100: 'numpad 4',
        101: 'numpad 5',
        102: 'numpad 6',
        103: 'numpad 7',
        104: 'numpad 8',
        105: 'numpad 9',
        106: 'multiply',
        107: 'add',
        109: 'subtract',
        110: 'decimal point',
        111: 'divide',
        112: 'f1',
        113: 'f2',
        114: 'f3',
        115: 'f4',
        116: 'f5',
        117: 'f6',
        118: 'f7',
        119: 'f8',
        120: 'f9',
        121: 'f10',
        122: 'f11',
        123: 'f12',
        144: 'num lock',
        145: 'scroll lock',
        186: 'semicolon',
        187: 'equal sign',
        188: 'comma',
        189: 'dash',
        190: 'period',
        191: 'forward slash',
        192: 'grave accent',
        219: 'open bracket',
        220: 'back slash',
        221: 'close bracket',
        222: 'single quote'}    
    """Dictionary mapping key code integers to textual key description."""
    
    @others
</t>
<t tx="leo.20181129171706.60">class _BoolDevice(_MathDynamic, metaclass=ABCMeta):

    @others
</t>
<t tx="leo.20181129171706.61">def __init__(self, mininputqty, *args, **kwargs):
    """
    Required Inputs
    
    * **mininputqty** minimum number of inputs possible
    
    Optional keyword arguments
    
    * **namedinputs** list of input names
    """
    self.In = [None]*mininputqty
    self.Enable = True
    namedinputs = kwargs.get('namedinputs', [])
    self._indict = {name:self.Eval(None) for name in namedinputs}
    self.ingetvalue = False
    self.lastget = False
    self.resetval = False
    self.firsttime = True


</t>
<t tx="leo.20181129171706.62">@property
def In(self):
    return self._input

</t>
<t tx="leo.20181129171706.63">@In.setter
def In(self, val):
    try:
        self._input = [self.Eval(v) for v in list(val)]
    except TypeError:
        self._input = [self.Eval(val)]
        
# Enable attribute controls the "tri-state" of output
</t>
<t tx="leo.20181129171706.64">@property
def Enable(self):
    return self._enable

</t>
<t tx="leo.20181129171706.65">@Enable.setter
def Enable(self, val):
    self._enable = self.Eval(val)
    
</t>
<t tx="leo.20181129171706.66">@abstractmethod
@_recursiontrap     # MUST use with any implementation that may recurse!
def _getvalue(self):
    return None

</t>
<t tx="leo.20181129171706.67">def _inputState(self, value):
    """
    interprets a value that could be single input or a list of inputs!
    """
    try:
        inputs = [].extend(value)
    except TypeError:
        inputs = [value]
    scalars = [v() for v in inputs]
    ones = scalars.count(True) + scalars.count(1)
    zeros = scalars.count(False) + scalars.count(0)
    if ones &gt; 0 and zeros &gt; 0:
        raise ValueError("Conflicting inputs found")
    if ones &gt; 0:
        return True
    elif zeros &gt; 0:
        return False
    else: 
        return None

</t>
<t tx="leo.20181129171706.68">def __call__(self):
    if self.Enable:
        return self._getvalue()
    else:
        return None

</t>
<t tx="leo.20181129171706.69">def GetInput(self, inputname):
    return self._inputState(self._indict[inputname])

</t>
<t tx="leo.20181129171706.7">def __init__(self, hwevent):
    """
    The event is initialized by the system, with a `hwevent` input parameter.
    """
    super().__init__(hwevent)
    self.keynum = hwevent.keyCode
    """The `keynum` attribute identifies a keycode (number)."""
    self.key = self.keys[hwevent.keyCode]
    """
    The `key` attribute identifes the key in text form (e.g. 'back slash').

    The list of key numbers and description strings follows::

        8: 'backspace',
        9: 'tab',
        13: 'enter',
        16: 'shift',
        17: 'ctrl',
        18: 'alt',
        19: 'pause/break',
        20: 'caps lock',
        27: 'escape',
        32: 'space',
        33: 'page up',
        34: 'page down',
        35: 'end',
        36: 'home',
        37: 'left arrow',
        38: 'up arrow',
        39: 'right arrow',
        40: 'down arrow',
        45: 'insert',
        46: 'delete',
        48: '0',
        49: '1',
        50: '2',
        51: '3',
        52: '4',
        53: '5',
        54: '6',
        55: '7',
        56: '8',
        57: '9',
        65: 'a',
        66: 'b',
        67: 'c',
        68: 'd',
        69: 'e',
        70: 'f',
        71: 'g',
        72: 'h',
        73: 'i',
        74: 'j',
        75: 'k',
        76: 'l',
        77: 'm',
        78: 'n',
        79: 'o',
        80: 'p',
        81: 'q',
        82: 'r',
        83: 's',
        84: 't',
        85: 'u',
        86: 'v',
        87: 'w',
        88: 'x',
        89: 'y',
        90: 'z',
        91: 'left window key',
        92: 'right window key',
        93: 'select key',
        96: 'numpad 0',
        97: 'numpad 1',
        98: 'numpad 2',
        99: 'numpad 3',
        100: 'numpad 4',
        101: 'numpad 5',
        102: 'numpad 6',
        103: 'numpad 7',
        104: 'numpad 8',
        105: 'numpad 9',
        106: 'multiply',
        107: 'add',
        109: 'subtract',
        110: 'decimal point',
        111: 'divide',
        112: 'f1',
        113: 'f2',
        114: 'f3',
        115: 'f4',
        116: 'f5',
        117: 'f6',
        118: 'f7',
        119: 'f8',
        120: 'f9',
        121: 'f10',
        122: 'f11',
        123: 'f12',
        144: 'num lock',
        145: 'scroll lock',
        186: 'semicolon',
        187: 'equal sign',
        188: 'comma',
        189: 'dash',
        190: 'period',
        191: 'forward slash',
        192: 'grave accent',
        219: 'open bracket',
        220: 'back slash',
        221: 'close bracket',
        222: 'single quote'

    """
</t>
<t tx="leo.20181129171706.70">def SetInput(self, inputname, reference):
    self._indict[inputname] = self.Eval(reference)



</t>
<t tx="leo.20181129171706.71">class _BoolOneInput(_BoolDevice):

    @others
</t>
<t tx="leo.20181129171706.72">def __init__(self, *args, **kwargs):
    """ 
    No Required Inputs
    """
    super().__init__(1, *args, **kwargs)


</t>
<t tx="leo.20181129171706.73">class _BoolMultiInput(_BoolDevice):

    @others
</t>
<t tx="leo.20181129171706.74">def __init__(self, *args, **kwargs):
    """ 
    No Required Inputs
    """
    super().__init__(2, *args, **kwargs)


</t>
<t tx="leo.20181129171706.75">class BoolNOT(_BoolOneInput):

    @others
</t>
<t tx="leo.20181129171706.76">@_recursiontrap
def _getvalue(self):
    inval = self._inputState(self.In[0])
    if inval == None:
        return True  # equivalent to an "open" input
    else:
        return not inval


</t>
<t tx="leo.20181129171706.77">class BoolAND(_BoolMultiInput):
    
    @others
</t>
<t tx="leo.20181129171706.78">@_recursiontrap
def _getvalue(self):
    for v in self._input:
        if not self._inputState(v):
            return False
    return True
    
</t>
<t tx="leo.20181129171706.79">class BoolNOR(_BoolMultiInput):
    
    @others
</t>
<t tx="leo.20181129171706.8">def module_exists(module_name):
    try:
        __import__(module_name)
    except ImportError:
        return False
    else:
        return True

</t>
<t tx="leo.20181129171706.80">@_recursiontrap
def _getvalue(self):
    for v in self._input:
        if self._inputState(v):
            return False
    return True
    
</t>
<t tx="leo.20181129171706.81">class BoolNAND(_BoolMultiInput):
    
    @others
</t>
<t tx="leo.20181129171706.82">@_recursiontrap
def _getvalue(self):
    for v in self._input:
        if not self._inputState(v):
            return True
    return False
    
</t>
<t tx="leo.20181129171706.83">class BoolSRFF(_BoolOneInput):
    
    @others
'''  This must be re-implemented to prevent recursion
class BoolJKFF(_BoolOneInput):
    
    def __init__(self, *args, **kwargs):
        """
        JK Flip Flop
        
        Optional keyword arguments
        
        """
        self.InputNames = ['J','K','CLK']
        kwargs['namedinputs'] = self.InputNames
        super().__init__(*args, **kwargs)
        self.IC1 = BoolNAND()
        self.IC2 = BoolNAND()
        self.ICJ = BoolNAND()
        self.ICK = BoolNAND()
        self.IC1.In = self.ICJ, self.IC2
        self.IC2.In = self.ICK, self.IC1
        
    # we can only assign ICJ, ICK inputs when this device's inputs are set
    def SetInput(self, inputname, reference):
        super().SetInput(inputname, reference)
        for i in self.InputNames:
            if self._indict[i]() is None:
                return
        self.ICJ.In = self.IC2, self._indict['J'], self._indict['CLK']
        self.ICK.In = self.IC1, self._indict['K'], self._indict['CLK']
    
    def _getvalue(self):
        return self.IC1()
        
    def Q_(self):
        return self.IC2()
        
    def Q(self):
        return self._getvalue()
'''

"""
class TestDevice(_BoolOneInput):
    
    def __init__(self, *args, **kwargs):
        kwargs['namedinputs'] = ['in1', 'in2']
        super().__init__(*args, **kwargs)
        
    def out1(self):
        return self.GetInput('in1') and self.GetInput('in2')
        
    def out2(self):
        return self.GetInput('in1') or self.GetInput('in2')
        
    def _getvalue(self):
        return None
"""        
        
</t>
<t tx="leo.20181129171706.84">def __init__(self, *args, **kwargs):
    """
    SR Flip Flop
    
    Optional keyword arguments
    
    * **gateclass** one of BoolNAND or BoolNOR (default)
    """
    kwargs['namedinputs'] = ['R','S']
    super().__init__(*args, **kwargs)
    gate = kwargs.get('gateclass', BoolNOR)
    self.IC1 = gate()
    self.IC2 = gate()

# we can only assign IC1 and IC2 inputs when this device's inputs are set
</t>
<t tx="leo.20181129171706.85">def SetInput(self, inputname, reference):
    super().SetInput(inputname, reference)
    if inputname == 'R':
        self.IC1.In = reference, self.IC2
    elif inputname == 'S':
        self.IC2.In = reference, self.IC1

    
</t>
<t tx="leo.20181129171706.86">def _getvalue(self):
    return self.IC1()
    
</t>
<t tx="leo.20181129171706.87">def Q_(self):
    return self.IC2()
    
</t>
<t tx="leo.20181129171706.88">def Q(self):
    return self._getvalue()
    
</t>
<t tx="leo.20181129171706.89">"""
These mathematics and geometry extensions subclass the :class:`~ggame.app.App` 
and :class:`~ggame.sprite.Sprite` classes to create a framework for building
apps that mimic some of the functionality of online math tools like Geogebra.

This :mod:`~ggame.mathapp` module implements base classes for
:class:`~ggame.sprite.Sprite`-based classes defined in this module.

These extensions are very experimental and are not fully developed!
"""

from abc import ABCMeta, abstractmethod
from time import time
from math import sqrt
from collections import namedtuple
from ggame.sprite import Sprite
from ggame.asset import Color, LineStyle, ImageAsset
from ggame.app import App


</t>
<t tx="leo.20181129171706.9">from ggame.mathapp import _MathVisual
from ggame.asset import Frame, ImageAsset

</t>
<t tx="leo.20181129171706.90">class MathApp(App):
    """
    MathApp is a subclass of the ggame :class:`~ggame.app.App` class. It 
    incorporates the following extensions:
    
    * Support for zooming the display using the mouse wheel
    * Support for click-dragging the display using the mouse button
    * Automatic execution of step functions in all objects and sprites
        sub-classed from :class:`_MathDynamic`.
        
    :param float scale: Optional parameter sets the initial scale of the
        display in units of pixels per logical unit. The default is 200.
        
    :returns: MathApp instance
    """
    
    _scale = 200   # pixels per unit
    _xcenter = 0    # center of screen in units
    _ycenter = 0    
    _mathVisualList = [] #
    _mathDynamicList = []
    _mathMovableList = []
    _mathSelectableList = []
    _mathStrokableList = []
    _viewNotificationList = []
    time = time()
    
    @others
</t>
<t tx="leo.20181129171706.91">def __init__(self, scale=_scale):
    super().__init__()
    MathApp.width = self.width
    MathApp.height = self.height
    MathApp._scale = scale   # pixels per unit
    # register event callbacks
    self.listenMouseEvent("click", self._handleMouseClick)
    self.listenMouseEvent("mousedown", self._handleMouseDown)
    self.listenMouseEvent("mouseup", self._handleMouseUp)
    self.listenMouseEvent("mousemove", self._handleMouseMove)
    self.listenMouseEvent("wheel", self._handleMouseWheel)
    self.mouseDown = False
    self.mouseCapturedObject = None
    self.mouseStrokedObject = None
    self.mouseDownObject = None
    self.mouseX = self.mouseY = None
    self._touchAllVisuals()
    self.selectedObj = None
    MathApp.time = time()

</t>
<t tx="leo.20181129171706.92">def step(self):
    """
    The step method overrides :func:`~ggame.app.App.step` in the 
    :class:`~ggame.app.App` class, executing step functions in all
    objects subclassed from :class:`_MathDynamic`.
    """
    MathApp.time = time()
    for spr in self._mathDynamicList:
        spr.step()

</t>
<t tx="leo.20181129171706.93">def _touchAllVisuals(self):
    # touch all visual object assets to use scaling
    for obj in self._mathVisualList:
        obj._touchAsset(True)


</t>
<t tx="leo.20181129171706.94">@classmethod
def logicalToPhysical(cls, lp):
    """
    Transform screen coordinates from logical to physical space. Output
    depends on the current 'zoom' and 'pan' of the screen.
    
    :param tuple(float,float) lp: Logical screen coordinates (x, y)
    
    :rtype: tuple(float,float)
    
    :returns: Physical screen coordinates (x, y)
    """
    
    xxform = lambda xvalue, xscale, xcenter, physwidth: int((xvalue-xcenter)*xscale + physwidth/2)
    yxform = lambda yvalue, yscale, ycenter, physheight: int(physheight/2 - (yvalue-ycenter)*yscale)

    try:
        return (xxform(lp[0], cls._scale, cls._xcenter, cls._win.width),
            yxform(lp[1], cls._scale, cls._ycenter, cls._win.height))
    except AttributeError:
        return lp
        
</t>
<t tx="leo.20181129171706.95">@classmethod
def physicalToLogical(cls, pp):
    """
    Transform screen coordinates from physical to logical space. Output
    depends on the current 'zoom' and 'pan' of the screen.
    
    :param tuple(float,float) lp: Physical screen coordinates (x, y)
    
    :rtype: tuple(float,float)
    
    :returns: Logical screen coordinates (x, y)
    """
    
    xxform = lambda xvalue, xscale, xcenter, physwidth: (xvalue - physwidth/2)/xscale + xcenter
    yxform = lambda yvalue, yscale, ycenter, physheight: (physheight/2 - yvalue)/yscale + ycenter

    try:
        return (xxform(pp[0], cls._scale, cls._xcenter, cls._win.width),
            yxform(pp[1], cls._scale, cls._ycenter, cls._win.height))
    except AttributeError:
        return pp
        
</t>
<t tx="leo.20181129171706.96">@classmethod
def translateLogicalToPhysical(cls, pp):
    """
    Transform screen translation from logical to physical space. Output
    only depends on the current 'zoom' of the screen.
    
    :param tuple(float,float) lp: Logical screen translation pair 
        (delta x, delta y)
    
    :rtype: tuple(float,float)
    
    :returns: Physical screen translation ordered pair (delta x, delta y)
    """
    
    xxform = lambda xvalue, xscale: xvalue*xscale
    yxform = lambda yvalue, yscale: -yvalue*yscale

    try:
        return (xxform(pp[0], cls._scale), yxform(pp[1], cls._scale))
    except AttributeError:
        return pp

</t>
<t tx="leo.20181129171706.97">@classmethod
def translatePhysicalToLogical(cls, pp):
    """
    Transform screen translation from physical to logical space. Output
    only depends on the current 'zoom' of the screen.
    
    :param tuple(float,float) lp: Physical screen translation pair 
        (delta x, delta y)
    
    :rtype: tuple(float,float)
    
    :returns: Logical screen translation ordered pair (delta x, delta y)
    """
    
    xxform = lambda xvalue, xscale: xvalue/xscale
    yxform = lambda yvalue, yscale: -yvalue/yscale

    try:
        return (xxform(pp[0], cls._scale), yxform(pp[1], cls._scale))
    except AttributeError:
        return pp

</t>
<t tx="leo.20181129171706.98">def _handleMouseClick(self, event):
    found = False
    for obj in self._mathSelectableList:
        if obj.physicalPointTouching((event.x, event.y)):
            found = True
            if not obj.selected: 
                obj.select()
                self.selectedObj = obj
    if not found and self.selectedObj:
        self.selectedObj.unselect()
        self.selectedObj = None

</t>
<t tx="leo.20181129171706.99">def _handleMouseDown(self, event):
    self.mouseDown = True
    self.mouseCapturedObject = None
    self.mouseStrokedObject = None
    for obj in self._mathSelectableList:
        if obj.physicalPointTouching((event.x, event.y)):
            obj.mousedown()
            self.mouseDownObject = obj
            break
    for obj in self._mathMovableList:
        if obj.physicalPointTouching((event.x, event.y)) and not (obj.strokable and obj.canstroke((event.x,event.y))):
            self.mouseCapturedObject = obj
            break
    if not self.mouseCapturedObject:
        for obj in self._mathStrokableList:
            if obj.canstroke((event.x, event.y)):
                self.mouseStrokedObject = obj
                break

</t>
<t tx="leo.20181129171707.1">@viewPosition.setter
def viewPosition(self, pos):
    MathApp._xcenter, MathApp._ycenter = pos
    self._touchAllVisuals()
    self._viewNotify("translate")
    
</t>
<t tx="leo.20181129171707.10">@classmethod
def _removeVisual(cls, obj):
    if isinstance(obj, _MathVisual) and obj in cls._mathVisualList:
        cls._mathVisualList.remove(obj)

</t>
<t tx="leo.20181129171707.100">def _buildAsset(self):
    return self._imageasset

</t>
<t tx="leo.20181129171707.101">def physicalPointTouching(self, ppos):
    """
    Determine if a physical point is considered to be touching point's 
    image.
    
    :param tuple(int,int) ppos: Physical screen coordinates.
    :rtype: boolean
    :returns: True if touching, False otherwise.
    """
    self._setExtents()  # ensure xmin, xmax are correct
    x, y = ppos
    return x &gt;= self.xmin and x &lt; self.xmax and y &gt;= self.ymin and y &lt;= self.ymax
</t>
<t tx="leo.20181129171707.102">def module_exists(module_name):
    try:
        __import__(module_name)
    except ImportError:
        return False
    else:
        return True

# PYTHON 3 and PYGAME DEPENDENCIES
</t>
<t tx="leo.20181129171707.103">from ggame.mathapp import MathApp, _MathVisual
from ggame.asset import RectangleAsset, LineStyle, Color
from ggame.sprite import Sprite

</t>
<t tx="leo.20181129171707.104">class Slider(_MathVisual):
    """
    Create a 'slider' style numeric input control on the screen. This is a 
    subclass of :class:`~ggame.sprite.Sprite` and 
    :class:`~ggame.mathapp._MathVisual` but most of the inherited 
    members are of little use and are not shown in the documentation. 


    :param \*args:
        See below
    :param \**kwargs:
        See below

    :Required Arguments:
        * **pos**  (*tuple(float,float)*) Screen position of the slider, which may
            be a literal tuple of floats, or a reference to any object or 
            function that returns or evaluates to a tuple of floats.
        * **minval** (*float*) The minimum value of the slider
        * **maxval** (*float*) The maximum value of the slider
        * **initial** (*float*) The initial value of the slider


    :Optional Keyword Arguments:
        * **steps** (*int*) Number of steps between minval and maxval (default 50)
        * **leftkey** (*str*) Name of a keyboard key that will make the 
            slider control step down (move left) (default None). See 
            :class:`~ggame.event.KeyEvent` for a list of names.
        * **rightkey** (*str*) Name of a keyboard key that will make the slider
            control step up (move right) (default None) 
        * **centerkey** (*str*) Name of a keyboard key that will make the slider
            move to its center position (default None)
        * **positioning** (*str*) One of 'logical' or 'physical'
        * **size** (*int*) Width of the slider (in pixels)
        * **color** (*Color*) Valid :class:`~ggame.asset.Color` object
        * **style** (*LineStyle*) Valid :class:`~ggame.asset.LineStyle` object
        
    Example::
    
    
        from ggame.slider import Slider
        from ggame.mathapp import MathApp
    
        s = Slider(
            (100, 150),     # screen position
            0,              # minimum value
            250,            # maximum value
            125,            # initial value
            positioning='physical', # use physical coordinates for position
            steps=10)       # 10 steps between 125 and 250
            
        MathApp().run()

        
    """    
    _posinputsdef = ['pos']
    _nonposinputsdef = ['minval','maxval','initial']

    @others
</t>
<t tx="leo.20181129171707.105">def __init__(self, *args, **kwargs):
    super().__init__(
        RectangleAsset(1, 1), *args, **kwargs)
    self._val = self._nposinputs.initial()
    self._steps = kwargs.get('steps', 50)
    self._step = (self._nposinputs.maxval()-self._nposinputs.minval())/self._steps
    self._leftctrl = kwargs.get('leftkey', None)
    self._rightctrl = kwargs.get('rightkey', None)
    self._centerctrl = kwargs.get('centerkey', None)
    self.selectable = True  # must be after super init!
    self.strokable = True  # this enables grabbing/slideing the thumb
    self.thumbcaptured = False
    self._thumbwidth = max(self._stdinputs.width()/40, 1)
    self._thumb = Sprite(RectangleAsset(self._thumbwidth, 
        self._stdinputs.size()-2, LineStyle(1, self._stdinputs.color()), self._stdinputs.color()), 
        self._thumbXY())
    self._touchAsset()
    if self._leftctrl:
        MathApp.listenKeyEvent("keydown", self._leftctrl, self.moveLeft)
    if self._rightctrl:
        MathApp.listenKeyEvent("keydown", self._rightctrl, self.moveRight)
    if self._centerctrl:
        MathApp.listenKeyEvent("keydown", self._centerctrl, self.moveCenter)

</t>
<t tx="leo.20181129171707.106">def _thumbXY(self):
    minval = self._nposinputs.minval()
    maxval = self._nposinputs.maxval()
    return (self._spposinputs.pos[0]+(self._val-minval)*
            (self._sstdinputs.width-self._thumbwidth)/(maxval-minval),
            self._spposinputs.pos[1]+1)
        
</t>
<t tx="leo.20181129171707.107">def __call__(self):
    return self._val

</t>
<t tx="leo.20181129171707.108">@property
def value(self):
    return self._val
    
</t>
<t tx="leo.20181129171707.109">@value.setter
def value(self, val):
    self._setval(val)

</t>
<t tx="leo.20181129171707.11">@classmethod
def _addDynamic(cls, obj):
    if isinstance(obj, _MathDynamic) and not obj in cls._mathDynamicList:
        cls._mathDynamicList.append(obj)
        
</t>
<t tx="leo.20181129171707.110">def _buildAsset(self):
    self._setThumb()
    return RectangleAsset(
        self._stdinputs.width(), self._stdinputs.size(), 
        line=self._stdinputs.style(), fill=Color(0,0))

</t>
<t tx="leo.20181129171707.111">def _setThumb(self):
    self._thumb.position = self._thumbXY()
            
</t>
<t tx="leo.20181129171707.112">def step(self):
    pass

</t>
<t tx="leo.20181129171707.113">def _setval(self, val):
    minval = self._nposinputs.minval()
    maxval = self._nposinputs.maxval()
    if val &lt;= minval:
        self._val = minval
    elif val &gt;= maxval:
        self._val = maxval
    else:
        self._val = round((val - minval)*self._steps/(maxval-minval))*self._step + minval
    self._setThumb()
    
</t>
<t tx="leo.20181129171707.114">def increment(self, step):
    self._setval(self._val + step)
    
</t>
<t tx="leo.20181129171707.115">def select(self):
    super().select()
    if not self._leftctrl:
        MathApp.listenKeyEvent("keydown", "left arrow", self._moveLeft)
    if not self._rightctrl:
        MathApp.listenKeyEvent("keydown", "right arrow", self._moveRight)
    MathApp.listenMouseEvent("click", self._mouseClick)

</t>
<t tx="leo.20181129171707.116">def unselect(self):
    super().unselect()
    try:
        if not self._leftctrl:
            MathApp.unlistenKeyEvent("keydown", "left arrow", self._moveLeft)
        if not self._rightctrl:
            MathApp.unlistenKeyEvent("keydown", "right arrow", self._moveRight)
        MathApp.unlistenMouseEvent("click", self._mouseClick)
    except ValueError:
        pass

</t>
<t tx="leo.20181129171707.117">def _mouseClick(self, event):
    if self.physicalPointTouching((event.x, event.y)):
        if event.x &gt; self.thumb.x + self._thumbwidth:
            self._moveRight(event)
        elif event.x &lt; self.thumb.x:
            self._moveLeft(event)
            
</t>
<t tx="leo.20181129171707.118">def _moveLeft(self, event):
    self.increment(-self._step)

</t>
<t tx="leo.20181129171707.119">def _moveRight(self, event):
    self.increment(self._step)
    
</t>
<t tx="leo.20181129171707.12">@classmethod
def _removeDynamic(cls, obj):
    if isinstance(obj, _MathDynamic) and obj in cls._mathDynamicList:
        cls._mathDynamicList.remove(obj)

</t>
<t tx="leo.20181129171707.120">def _moveCenter(self, event):
    self._val = (self._snposinputs.minval + self._snposinputs.maxval)/2
    self._setThumb()
    
</t>
<t tx="leo.20181129171707.121">def canstroke(self, ppos):
    return self.physicalPointTouchingThumb(ppos)
    
</t>
<t tx="leo.20181129171707.122">def stroke(self, ppos, pdisp):
    _ppos = self._spposinputs.pos
    minval = self._snposinputs.minval
    maxval = self._snposinputs.maxval
    xpos = ppos[0] + pdisp[0]
    self.value = (xpos - _ppos[0])*(maxval-minval)/self._sstdinputs.width + minval

</t>
<t tx="leo.20181129171707.123">def physicalPointTouching(self, ppos):
    _ppos = self._spposinputs.pos
    return (ppos[0] &gt;= _ppos[0] and 
        ppos[0] &lt;= _ppos[0] + self._sstdinputs.width and
        ppos[1] &gt;= _ppos[1] and 
        ppos[1] &lt;= _ppos[1] + self._sstdinputs.size)

</t>
<t tx="leo.20181129171707.124">def physicalPointTouchingThumb(self, ppos):
    thumbpos = self._thumbXY()
    return (ppos[0] &gt;= thumbpos[0] and 
        ppos[0] &lt;= thumbpos[0] + self._thumbwidth + 2 and
        ppos[1] &gt;= thumbpos[1] and 
        ppos[1] &lt;= thumbpos[1] + self._sstdinputs.size - 2)

</t>
<t tx="leo.20181129171707.125">def translate(self, pdisp):
    pass

</t>
<t tx="leo.20181129171707.126">def destroy(self):
    self._thumb.destroy()
    super().destroy()
</t>
<t tx="leo.20181129171707.127">try:
    from ggame.sysdeps import *
except:
    from sysdeps import *

</t>
<t tx="leo.20181129171707.128">class SoundAsset(object):
    """
    Class representing a single sound asset (sound file, such as .mp3 or .wav).

    :param str url: The URL or file name of the desired sound. Sound file 
        formats may include `.wav` or `.mp3`, subject to browser compatibility. 
    
    :returns: The asset instance
    """    
    @others
</t>
<t tx="leo.20181129171707.129">def __init__(self, url):
    self.url = url
    """
    A string containing the url or name of the asset file.
    """

    
</t>
<t tx="leo.20181129171707.13">@classmethod
def _addMovable(cls, obj):
    if isinstance(obj, _MathVisual) and not obj in cls._mathMovableList:
        cls._mathMovableList.append(obj)
        
</t>
<t tx="leo.20181129171707.130">class Sound(object):
    """
    The Sound class represents a sound, with methods for controlling
    when and how the sound is played in the application.
    
    :param SoundAsset asset: A valid :class:`SoundAsset` instance.
    
    :returns: the Sound instance
    """

    @others
</t>
<t tx="leo.20181129171707.131">def __init__(self, asset):
    self.asset = asset
    """
    A reference to the sound asset instance.
    """
    self.SND = SND_Sound(self.asset.url)
    """
    A reference to the underlying sound object provided by the system.
    """
    self.SND.load()
    
</t>
<t tx="leo.20181129171707.132">def play(self):
    """
    Play the sound once.
    """
    self.stop()
    self.SND.play()

</t>
<t tx="leo.20181129171707.133">def loop(self):
    """
    Play the sound continuously, looping forever.
    """
    self.stop()
    self.SND.loop()
    self.SND.play()
    
</t>
<t tx="leo.20181129171707.134">def stop(self):
    """
    Stop playing the sound.
    """
    self.SND.stop()
    
</t>
<t tx="leo.20181129171707.135">@property
def volume(self):
    """
    The volume property is a number ranging from 0-100 that 
    represents the volume or intensity of the sound when it is playing.
    """
    return self.SND.getVolume()
    
</t>
<t tx="leo.20181129171707.136">@volume.setter
def volume(self, value):
    self.SND.setVolume(value)

</t>
<t tx="leo.20181129171707.137">try:
    from ggame.sysdeps import *
except:
    from sysdeps import *
import math
from ggame.asset import *
from ggame.app import *


</t>
<t tx="leo.20181129171707.138">class Sprite(object):
    """
    The Sprite class combines the idea of a visual/graphical asset, a
    position on the screen, and *behavior*. Although the Sprite can be
    used as-is, it is generally subclassed to give it some desired behavior.

    When subclassing the Sprite class, you may customize the initialization
    code to use a specific asset. A 'step' or 'poll' method may be added
    for handling per-frame actions (e.g. checking for collisions). Step or poll
    functions are not automatically called by the :class:`~ggame.app.App` class, 
    but you may subclass the :class:`~ggame.app.App` class in order to do this.

    Furthermore, you may wish to define event callback methods in your customized
    sprite class. With customized creation, event handling, and periodic processing
    you can achieve fully autonomous behavior for your sprite objects. 

    :param asset asset: An existing graphical asset
    
    :param tuple(int,int) pos:  The sprite position may be provided, which 
        specifies the starting (x,y) coordinates of the sprite on the screen. 
        By default, the position of a sprite defines the location of its upper-left 
        hand corner. This behavior can be modified by customizing its
        :data:`center`.
    
    :param asset edgedef: An edge definition asset may be provided, which
        specifies an asset that will be used to define the boundaries of
        the sprite for the purpose of collision detection. If no `edgedef` 
        asset is given, the required asset is used, which will be a rectangular
        asset in the case of an image texture. This option is typically used
        to define a visible image outline for a texture-based sprite that has
        a transparent texture image background.
    
    :returns: Nothing. If the position is on screen the sprite will be displayed
        in the browser.
    
    Example::
    
        from ggame.sprite import Sprite
        from ggame.asset import ImageAsset, CircleAsset
        from ggame.app import App
        
        player = Sprite(
            ImageAsset("player.png", 
            (100,100), 
            CircleAsset(50))

        App().run()

    This creates a sprite using the 'player.png' image, positioned with its
    upper-left corner at coordinates (100,100) and with a 50 pixel radius 
    circular collision border. 

    """
 
    _rectCollision = "rect"
    _circCollision = "circ"
    
    @others
</t>
<t tx="leo.20181129171707.139">def __init__(self, asset, pos=(0,0), edgedef=None):
    """
    """
    self._index = 0
    if type(asset) == ImageAsset:
        self.asset = asset
        try:
            #self.GFX = GFX_Sprite()
            self.GFX = GFX_Sprite(asset.GFX) # GFX is PIXI Sprite
        except:
            self.GFX = None
    elif type(asset) in [RectangleAsset, 
        CircleAsset, 
        EllipseAsset, 
        PolygonAsset,
        LineAsset,
        ]:
        self.asset = asset
        self.GFX = GFX_Sprite(asset.GFX.generateTexture())
        #self.GFX = asset.GFX.clone() # GFX is PIXI Graphics (from Sprite)
        #self.GFX.visible = True
    elif type(asset) in [TextAsset]:
        self.asset = asset._clone()
        self.GFX = self.asset.GFX # GFX is PIXI Text (from Sprite)
        self.GFX.visible = True
    if not edgedef:
        self.edgedef = asset
    else:
        self.edgedef = edgedef
    self.xmin = self.xmax = self.ymin = self.ymax = 0
    self.position = pos
    """Tuple indicates the position of the sprite on the screen."""
    self._extentsdirty = True
    """Boolean indicates if extents must be calculated before collision test"""
    self._createBaseVertices()
    self._setExtents()
    """Initialize the extents (xmax, xmin, etc.) for collision detection"""
    App._add(self)
    
</t>
<t tx="leo.20181129171707.14">@classmethod
def _removeMovable(cls, obj):
    if isinstance(obj, _MathVisual) and obj in cls._mathMovableList:
        cls._mathMovableList.remove(obj)

</t>
<t tx="leo.20181129171707.140">def _createBaseVertices(self):
    """
    Create sprite-relative list of vertex coordinates for boundary
    """
    self._basevertices = []
    assettype = type(self.edgedef)
    if assettype in [RectangleAsset, ImageAsset, TextAsset]:
        self._basevertices = [(0,0), 
            (0,self.edgedef.height), 
            (self.edgedef.width,self.edgedef.height),
            (self.edgedef.width,0)]
    elif assettype is PolygonAsset:
        self._basevertices = self.edgedef.path[:-1]
    elif assettype is LineAsset:
        self._basevertices = [(0,0), 
            (self.edgedef.deltaX, self.edgedef.deltaY)]
    elif assettype is EllipseAsset:
        w = self.edgedef.halfw * 2
        h = self.edgedef.halfh * 2
        self._basevertices = [(0,0), (0,h), (w,h), (w,0)]

</t>
<t tx="leo.20181129171707.141">def _xformVertices(self):
    """
    Create window-relative list of vertex coordinates for boundary
    """
    # find center as sprite-relative points (note sprite may be scaled)
    x = self.width * self.fxcenter / self.scale
    y = self.height * self.fycenter / self.scale
    if self.scale != 1.0:
        sc = self.scale
        # center-relative, scaled coordinates
        crsc = [((xp-x)*sc,(yp-y)*sc) for xp,yp in self._basevertices]
    else:
        crsc = [(xp-x,yp-y) for xp,yp in self._basevertices]
        
    # absolute, rotated coordinates
    c = math.cos(self.rotation)
    s = math.sin(self.rotation)
    self._absolutevertices = [(self.x + x*c + y*s, self.y + -x*s + y*c) 
                                for x,y in crsc]


</t>
<t tx="leo.20181129171707.142">def _setExtents(self):
    """
    update min/max x and y based on position, center, width, height
    """
    if self._extentsdirty:
        if type(self.asset) is CircleAsset:
            th = math.atan2(
                self.fycenter - 0.5, 0.5 - self.fxcenter) + self.rotation
            D = self.width
            L = math.sqrt(math.pow(self.fxcenter - 0.5, 2) + 
                math.pow(self.fycenter - 0.5, 2)) * D
            self.xmin = self.x + int(L*math.cos(th)) - D//2
            self.ymin = self.y - int(L*math.sin(th)) - D//2
            self.xmax = self.xmin + D
            self.ymax = self.ymin + D
        else:
            # Build vertex list
            self._xformVertices()
            x, y = zip(*self._absolutevertices)
            self.xmin = min(x)
            self.xmax = max(x)
            self.ymin = min(y)
            self.ymax = max(y)
        self._extentsdirty = False

</t>
<t tx="leo.20181129171707.143">def firstImage(self):
    """
    Select and display the *first* image used by this sprite. This only 
    does something useful if the asset is an :class:`~ggame.asset.ImageAsset`
    defined with multiple images.
    """
    self.GFX.texture = self.asset[0]

</t>
<t tx="leo.20181129171707.144">def lastImage(self):
    """
    Select and display the *last* image used by this sprite. This only 
    does something useful if the asset is an :class:`~ggame.asset.ImageAsset`
    defined with multiple images.
    """
    self.GFX.texture = self.asset[-1]

</t>
<t tx="leo.20181129171707.145">def nextImage(self, wrap = False):
    """
    Select and display the *next* image used by this sprite.
    If the current image is already the *last* image, then
    the image is not advanced.
    
    :param boolean wrap: If `True`, then calling 
        :meth:`nextImage` on the last image will cause the *first*
        image to be loaded.
    
    This only does something useful if the asset is an 
    :class:`~ggame.asset.ImageAsset` defined with multiple images.
    """
    self._index += 1
    if self._index &gt;= len(self.asset):
        if wrap:
            self._index = 0
        else:
            self._index = len(self.asset)-1
    self.GFX.texture = self.asset[self._index]

</t>
<t tx="leo.20181129171707.146">def prevImage(self, wrap = False):
    """
    Select and display the *previous* image used by this sprite.
    If the current image is already the *first* image, then
    the image is not changed.

    :param boolean wrap: If `True`, then calling 
        :meth:`prevImage` on the first image will cause the *last*
        image to be loaded.
    
    This only does something useful if the asset is an 
    :class:`~ggame.asset.ImageAsset` defined with multiple images.
    """
    self._index -= 1
    if self._index &lt; 0:
        if wrap:
            self._index = len(self.asset)-1
        else:
            self._index = 0
    self.GFX.texture = self.asset[self._index]

</t>
<t tx="leo.20181129171707.147">def setImage(self, index=0):
    """
    Select the image to display by giving its `index`.
    
    :param int index: An index to specify the image to display.
        A value of zero represents the *first* image in the asset.

    This is equivalent to setting the :data:`index` property
    directly.
    
    This only does something useful if the asset is an 
    :class:`~ggame.asset.ImageAsset` defined with multiple images.
    """
    self.index = index

</t>
<t tx="leo.20181129171707.148">def rectangularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass

</t>
<t tx="leo.20181129171707.149">def circularCollisionModel(self):
    """
    Obsolete. No op.
    """
    pass



</t>
<t tx="leo.20181129171707.15">@classmethod
def _addSelectable(cls, obj):
    if isinstance(obj, _MathVisual) and not obj in cls._mathSelectableList:
        cls._mathSelectableList.append(obj)
        
</t>
<t tx="leo.20181129171707.150">@property
def index(self):
    """This is an integer index into the list of images available for this sprite."""
    return self._index
    
</t>
<t tx="leo.20181129171707.151">@index.setter
def index(self, value):
    self._index = value
    try:
        self.GFX.texture = self.asset[self._index]
    except:
        self._index = 0
        self.GFX.texture = self.asset[self._index]

</t>
<t tx="leo.20181129171707.152">@property
def width(self):
    """
    This is an integer representing the display width of the sprite.
    Assigning a value to the width will scale the image horizontally.
    """
    return self.GFX.width
    
</t>
<t tx="leo.20181129171707.153">@width.setter
def width(self, value):
    self.GFX.width = value
    self._extentsdirty = True

</t>
<t tx="leo.20181129171707.154">@property
def height(self):
    """
    This is an integer representing the display height of the sprite.
    Assigning a value to the height will scale the image vertically.
    """
    return self.GFX.height

</t>
<t tx="leo.20181129171707.155">@height.setter
def height(self, value):
    self.GFX.height = value
    self._extentsdirty = True
    
</t>
<t tx="leo.20181129171707.156">@property
def x(self):
    """
    This represents the x-coordinate of the sprite on the screen. Assigning
    a value to this attribute will move the sprite horizontally.
    """
    return self.GFX.position.x
    
</t>
<t tx="leo.20181129171707.157">@x.setter
def x(self, value):
    deltax = value - self.GFX.position.x
    self.xmax += deltax
    self.xmin += deltax
    """Adjust extents directly with low overhead"""
    self.GFX.position.x = value

</t>
<t tx="leo.20181129171707.158">@property
def y(self):
    """
    This represents the y-coordinate of the sprite on the screen. Assigning
    a value to this attribute will move the sprite vertically.
    """
    return self.GFX.position.y
    
</t>
<t tx="leo.20181129171707.159">@y.setter
def y(self, value):
    deltay = value - self.GFX.position.y
    self.ymax += deltay
    self.ymin += deltay
    """Adjust extents directly with low overhead"""
    self.GFX.position.y = value

</t>
<t tx="leo.20181129171707.16">@classmethod
def _removeSelectable(cls, obj):
   if isinstance(obj, _MathVisual)  and obj in cls._mathSelectableList:
        cls._mathSelectableList.remove(obj)

</t>
<t tx="leo.20181129171707.160">@property
def position(self):
    """
    This represents the (x,y) coordinates of the sprite on the screen. Assigning
    a value to this attribute will move the sprite to the new coordinates.
    """
    return (self.GFX.position.x, self.GFX.position.y)
    
</t>
<t tx="leo.20181129171707.161">@position.setter
def position(self, value):
    self.x, self.y = value

</t>
<t tx="leo.20181129171707.162">@property
def fxcenter(self):
    """
    This represents the horizontal position of the sprite "center", as a floating
    point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
    of the sprite refers to its left hand edge. A value of 1.0 refers to its 
    right hand edge. Any value in between may be specified. Values may be assigned
    to this attribute. 
    """
    try:
        return self.GFX.anchor.x
    except:
        return 0.0
    
</t>
<t tx="leo.20181129171707.163">@fxcenter.setter
def fxcenter(self, value):
    try:
        self.GFX.anchor.x = value
        self._extentsdirty = True
    except:
        pass
    
</t>
<t tx="leo.20181129171707.164">@property
def fycenter(self):
    """
    This represents the vertical position of the sprite "center", as a floating
    point number between 0.0 and 1.0. A value of 0.0 means that the x-coordinate
    of the sprite refers to its top edge. A value of 1.0 refers to its 
    bottom edge. Any value in between may be specified. Values may be assigned
    to this attribute. 
    """
    try:
        return self.GFX.anchor.y
    except:
        return 0.0
    
</t>
<t tx="leo.20181129171707.165">@fycenter.setter
def fycenter(self, value):
    try:
        self.GFX.anchor.y = value
        self._extentsdirty = True
    except:
        pass

</t>
<t tx="leo.20181129171707.166">@property
def center(self):
    """
    This attribute represents the horizontal and vertical position of the 
    sprite "center" as a tuple of floating point numbers. See the 
    descriptions for :data:`fxcenter` and :data:`fycenter` for 
    more details.
    """
    try:
        return (self.GFX.anchor.x, self.GFX.anchor.y)
    except:
        return (0.0, 0.0)
    
</t>
<t tx="leo.20181129171707.167">@center.setter
def center(self, value):
    try:
        self.GFX.anchor.x = value[0]
        self.GFX.anchor.y = value[1]
        self._extentsdirty = True
    except:
        pass

</t>
<t tx="leo.20181129171707.168">@property
def visible(self):
    """
    This boolean attribute may be used to change the visibility of the sprite. Setting
    `~ggame.Sprite.visible` to `False` will prevent the sprite from rendering on the 
    screen.
    """
    return self.GFX.visible

</t>
<t tx="leo.20181129171707.169">@visible.setter
def visible(self, value):
    self.GFX.visible = value

</t>
<t tx="leo.20181129171707.17">@classmethod
def _addStrokable(cls, obj):
    if isinstance(obj, _MathVisual) and not obj in cls._mathStrokableList:
        cls._mathStrokableList.append(obj)
        
</t>
<t tx="leo.20181129171707.170">@property
def scale(self):
    """
    This attribute may be used to change the size of the sprite ('scale' it) on the 
    screen. Value may be a floating point number. A value of 1.0 means that the sprite
    image will keep its original size. A value of 2.0 would double it, etc.
    """
    try:
        return self.GFX.scale.x
    except AttributeError:
        return 1.0
    
</t>
<t tx="leo.20181129171707.171">@scale.setter
def scale(self, value):
    self.GFX.scale.x = value
    self.GFX.scale.y = value
    self._extentsdirty = True

</t>
<t tx="leo.20181129171707.172">@property
def rotation(self):
    """
    This attribute may be used to change the rotation of the sprite on the screen.
    Value may be a floating point number. A value of 0.0 means no rotation. A value 
    of 1.0 means  a rotation of 1 radian in a counter-clockwise direction. One radian
    is 180/pi or approximately 57.3 degrees.
    """
    try:
        return -self.GFX.rotation
    except AttributeError:
        return 0.0
    
</t>
<t tx="leo.20181129171707.173">@rotation.setter
def rotation(self, value):
    self.GFX.rotation = -value
    if value:
        self._extentsdirty = True

</t>
<t tx="leo.20181129171707.174">@classmethod
def collidingCircleWithPoly(cls, circ, poly):
    return True

</t>
<t tx="leo.20181129171707.175">def collidingPolyWithPoly(self, obj):
    return True

</t>
<t tx="leo.20181129171707.176">def collidingWith(self, obj):
    """
    Determine if this sprite is currently overlapping another
    sprite object.
    
    :param Sprite obj: A reference to another Sprite object.
    
    :rtype: boolean
    
    :returns: `True` if this the sprites are overlapping, `False` otherwise.
    """
    if self is obj:
        return False
    else:
        self._setExtents()
        obj._setExtents()
        # Gross check for overlap will usually rule out a collision
        if (self.xmin &gt; obj.xmax
            or self.xmax &lt; obj.xmin
            or self.ymin &gt; obj.ymax
            or self.ymax &lt; obj.ymin):
            return False
        # Otherwise, perform a careful overlap determination
        elif type(self.asset) is CircleAsset:
            if type(obj.asset) is CircleAsset:
                # two circles .. check distance between
                sx = (self.xmin + self.xmax) / 2
                sy = (self.ymin + self.ymax) / 2
                ox = (obj.xmin + obj.xmax) / 2
                oy = (obj.ymin + obj.ymax) / 2
                d = math.sqrt((sx-ox)**2 + (sy-oy)**2)
                return d &lt;= self.width/2 + obj.width/2
            else:
                return self.collidingCircleWithPoly(self, obj)
        else:
            if type(obj.asset) is CircleAsset:
                return self.collidingCircleWithPoly(obj, self)
            else:
                return self.collidingPolyWithPoly(obj)
            
            

</t>
<t tx="leo.20181129171707.177">def collidingWithSprites(self, sclass = None):
    """
    Determine if this sprite is colliding with any other sprites
    of a certain class.
    
    :param class sclass: A class identifier that is either :class:`Sprite`
        or a subclass of it that identifies the class of sprites to check
        for collisions. If `None` then all objects that are subclassed from
        the :class:`Sprite` class are checked.
        
    :rtype: list
    
    :returns: A (potentially empty) list of sprite objects of the given
        class that are overlapping with this sprite.
    """
    if sclass is None:
        slist = App.spritelist
    else:
        slist = App.getSpritesbyClass(sclass)
    return list(filter(self.collidingWith, slist))

</t>
<t tx="leo.20181129171707.178">def destroy(self):
    """
    Prevent the sprite from being displayed or checked in collision 
    detection. Once this is called, the sprite can no longer be displayed
    or used. If you only want to prevent a sprite from being displayed, 
    set the :data:`visible` attribute to `False`.
    """
    App._remove(self)
    self.GFX.destroy()
</t>
<t tx="leo.20181129171707.179">def module_exists(module_name):
    try:
        __import__(module_name)
    except ImportError:
        return False
    else:
        return True

</t>
<t tx="leo.20181129171707.18">@classmethod
def _removeStrokable(cls, obj):
    if isinstance(obj, _MathVisual) and obj in cls._mathStrokableList:
        cls._mathStrokableList.remove(obj)

</t>
<t tx="leo.20181129171707.19">@classmethod
def _destroy(cls, *args):
    """
    This will clean up any class level storage.
    """ 
    App._destroy(*args)  # hit the App class first
    MathApp.time = None
    MathApp._mathVisualList = [] 
    MathApp._mathDynamicList = []
    MathApp._mathMovableList = []
    MathApp._mathSelectableList = []
    MathApp._mathStrokableList = []
    MathApp._viewNotificationList = []
    

</t>
<t tx="leo.20181129171707.2">@classmethod   
def addViewNotification(cls, handler):
    """
    Register a function or method to be called in the event the view
    position or zoom changes.
    
    :param function handler: The function or method to be called
    :returns: Nothing
    """
    cls._viewNotificationList.append(handler)
    
</t>
<t tx="leo.20181129171707.20">class _MathDynamic(metaclass=ABCMeta):
    
    @others
</t>
<t tx="leo.20181129171707.21">def __init__(self):
    self._dynamic = False  # not switched on, by default!

</t>
<t tx="leo.20181129171707.22">def destroy(self):
    MathApp._removeDynamic(self)

</t>
<t tx="leo.20181129171707.23">def step(self):
    pass

</t>
<t tx="leo.20181129171707.24">def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
        
</t>
<t tx="leo.20181129171707.25">def _setDynamic(self):
    MathApp._addDynamic(self)
    self._dynamic = True
        

</t>
<t tx="leo.20181129171707.26">class _MathVisual(Sprite, _MathDynamic, metaclass=ABCMeta):
    """
    Abstract Base Class for all visual, potentially dynamic objects.
    
    :param Asset asset: A valid ggame asset object.
    
    :param list args: A list of required positional or non-positional arguments
        as named in the _posinputsdef and _nonposinputsdef lists overridden
        by child classes.
        
    :param \**kwargs:
        See below

    :Optional Keyword Arguments:
        * **positioning** (*string*) One of 'logical' or 'physical'
        * **size** (*int*) Size of the object (in pixels)
        * **width** (*int*) Width of the object (in pixels)
        * **color** (*Color*) Valid :class:`~ggame.asset.Color` object
        * **style** (*LineStyle*) Valid :class:`~ggame.asset.LineStyle` object
    """
    
    _posinputsdef = []  # a list of names (string) of required positional inputs
    _nonposinputsdef = []  # a list of names (string) of required non positional inputs
    _defaultsize = 15
    _defaultwidth = 200
    _defaultcolor = Color(0, 1)
    _defaultstyle = LineStyle(1, Color(0, 1))
    
    
    @others
</t>
<t tx="leo.20181129171707.27">def __init__(self, asset, *args, **kwargs):
    MathApp._addVisual(self)
    #Sprite.__init__(self, asset, args[0])
    _MathDynamic.__init__(self)
    self._movable = False
    self._selectable = False
    self._strokable = False
    self.selected = False
    """
    True if object is currently selected by the UI. 
    """
    self.mouseisdown = False
    """
    True if object is tracking UI mouse button as down. 
    """
    self._positioning = kwargs.get('positioning', 'logical')
    # positional inputs
    self._PI = namedtuple('PI', self._posinputsdef)
    # nonpositional inputs
    self._NPI = namedtuple('NPI', self._nonposinputsdef)
    # standard inputs (not positional)
    standardargs = ['size','width','color','style']
    self._SI = namedtuple('SI', standardargs)
    # correct number of args?
    if len(args) != len(self._posinputsdef) + len(self._nonposinputsdef):
        raise TypeError("Incorrect number of parameters provided")
    self._args = args
    # generated named tuple of functions from positional inputs
    self._posinputs = self._PI(*[self.Eval(p) for p in args][:len(self._posinputsdef)])
    self._getPhysicalInputs()
    # first positional argument must be a sprite position!
    Sprite.__init__(self, asset, self._pposinputs[0])
    # generated named tuple of functions from nonpositional inputs
    if len(self._nonposinputsdef) &gt; 0:
        self._nposinputs = self._NPI(*[self.Eval(p) for p in args][(-1*len(self._nonposinputsdef)):])
    else:
        self._nposinputs = []
    self._stdinputs = self._SI(self.Eval(kwargs.get('size', self._defaultsize)),
                                self.Eval(kwargs.get('width', self._defaultwidth)),
                                self.Eval(kwargs.get('color', self._defaultcolor)),
                                self.Eval(kwargs.get('style', self._defaultstyle)))
    self._sposinputs = self._PI(*[0]*len(self._posinputs))
    self._spposinputs = self._PI(*self._pposinputs)
    self._snposinputs = self._NPI(*[0]*len(self._nposinputs))
    self._sstdinputs = self._SI(*[0]*len(self._stdinputs))

</t>
<t tx="leo.20181129171707.28">def step(self):
    self._touchAsset()
    
</t>
<t tx="leo.20181129171707.29">def _saveInputs(self, inputs):
    self._sposinputs, self._spposinputs, self._snposinputs, self._sstdinputs = inputs
    
</t>
<t tx="leo.20181129171707.3">@classmethod   
def removeViewNotification(cls, handler):
    """
    Remove a function or method from the list of functions to be called
    in the event of a view position or zoom change.
    
    :param function handler: The function or method to be removed
    :returns: Nothing
    """
    cls._viewNotificationList.remove(handler)

</t>
<t tx="leo.20181129171707.30">def _getInputs(self):
    self._getPhysicalInputs()
    return (self._PI(*[p() for p in self._posinputs]),
        self._PI(*self._pposinputs),
        self._NPI(*[p() for p in self._nposinputs]),
        self._SI(*[p() for p in self._stdinputs]))


</t>
<t tx="leo.20181129171707.31">def _getPhysicalInputs(self):
    """
    Translate all positional inputs to physical
    """
    pplist = []
    if self._positioning == 'logical':
        for p in self._posinputs:
            pval = p()
            try:
                pp = MathApp.logicalToPhysical(pval)
            except AttributeError:
                pp = MathApp._scale * pval
            pplist.append(pp)
    else:
        # already physical
        pplist = [p() for p in self._posinputs]
    self._pposinputs = self._PI(*pplist)

</t>
<t tx="leo.20181129171707.32">def _inputsChanged(self, saved):
    return self._spposinputs != saved[1] or self._snposinputs != saved[2] or self._sstdinputs != saved[3]


</t>
<t tx="leo.20181129171707.33">def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)

</t>
<t tx="leo.20181129171707.34">def _updateAsset(self, asset):
    if type(asset) != ImageAsset:
        visible = self.GFX.visible
        if App._win != None:
            App._win.remove(self.GFX)
            self.GFX.destroy()
        self.asset = asset
        self.GFX = self.asset.GFX
        self.GFX.visible = visible        
        if App._win != None:
            App._win.add(self.GFX)
    self.position = self._pposinputs.pos
        
</t>
<t tx="leo.20181129171707.35">@property
def positioning(self):
    """
    Whether object was created with 'logical' or 'physical' positioning. 
    """
    return self._positioning

</t>
<t tx="leo.20181129171707.36">@positioning.setter
def positioning(self, val):
    pass

</t>
<t tx="leo.20181129171707.37">@property
def movable(self):
    """
    Whether object can be moved. Set-able and get-able. 
    """
    return self._movable
    
</t>
<t tx="leo.20181129171707.38">@movable.setter
def movable(self, val):
    if not self._dynamic:
        self._movable = val
        if val:
            MathApp._addMovable(self)
        else:
            MathApp._removeMovable(self)

</t>
<t tx="leo.20181129171707.39">@property
def selectable(self):
    """
    Whether object can be selected by the UI. Set-able and get-able.
    """
    return self._selectable
    
</t>
<t tx="leo.20181129171707.4">def _viewNotify(self, viewchange):
    for handler in self._viewNotificationList:
        handler(viewchange = viewchange, scale = self._scale, center = (self._xcenter, self._ycenter))
    
 
</t>
<t tx="leo.20181129171707.40">@selectable.setter
def selectable(self, val):
    self._selectable = val
    if val:
        MathApp._addSelectable(self)
    else:
        MathApp._removeSelectable(self)

</t>
<t tx="leo.20181129171707.41">@property
def strokable(self):
    """
    Whether the object supports a click-drag input from the UI mouse. 
    Set-able and get-able. 
    """
    return self._strokable
    
</t>
<t tx="leo.20181129171707.42">@strokable.setter
def strokable(self, val):
    self._strokable = val
    if val:
        MathApp._addStrokable(self)
    else:
        MathApp._removeStrokable(self)

</t>
<t tx="leo.20181129171707.43">def select(self):
    """
    Place the object in a 'selected' state. 
    
    :param: None
    :returns: None 
    """
    self.selected = True

</t>
<t tx="leo.20181129171707.44">def unselect(self):
    """
    Place the object in an 'unselected' state. 
    
    :param: None
    :returns: None
    """
    self.selected = False
    
</t>
<t tx="leo.20181129171707.45">def mousedown(self):
    """
    Inform the object of a 'mouse down' event. 
    
    :param: None 
    :returns: None 
    """
    self.mouseisdown = True
    
</t>
<t tx="leo.20181129171707.46">def mouseup(self):
    """
    Inform the object of a 'mouse up' event. 
    
    :param: None 
    :returns: None 
    """
    self.mouseisdown = False

</t>
<t tx="leo.20181129171707.47">def processEvent(self, event):
    """
    Inform the object of a generic ggame event. 
    
    :param event: The ggame event object to receive and process. 
    :returns: None 
    
    This method is intended to be overridden.
    """
    pass

</t>
<t tx="leo.20181129171707.48">@abstractmethod
def physicalPointTouching(self, ppos):
    """
    Determine if a physical point is considered to be touching this object.
    
    :param tuple(int,int) ppos: Physical screen coordinates.
    :rtype: boolean
    :returns: True if touching, False otherwise.
    
    This method **must** be overridden.
    """
    pass

</t>
<t tx="leo.20181129171707.49">@abstractmethod
def translate(self, pdisp):
    """ 
    Perform necessary processing in response to being moved by the mouse/UI.
    
    :param tuple(int,int) pdisp: Translation vector (x,y) in physical screen
        units.
    :returns: None
    
    This method **must** be overridden.
    """
    pass

</t>
<t tx="leo.20181129171707.5">@classmethod   
def distance(cls, pos1, pos2):
    """
    Utility for calculating the distance between any two points.
    
    :param tuple(float,float) pos1: The first point
    :param tuple(float,float) pos2: The second point
    :rtype: float
    :returns: The distance between the two points (using Pythagoras)
    """
    return sqrt((pos2[0]-pos1[0])**2 + (pos2[1]-pos1[1])**2)
    
</t>
<t tx="leo.20181129171707.50">def stroke(self, ppos, pdisp):
    """
    Perform necessary processing in response to click-drag action by the
    mouse/UI.
    
    :param tuple(int,int) ppos: Physical coordinates of stroke start.
    :param tuple(int,int) pdisp: Translation vector of stroke action in
        physical screen units.
    :returns: None
    
    This method is intended to be overridden.
    """
    pass

</t>
<t tx="leo.20181129171707.51">def canStroke(self, ppos):
    """
    Can the object respond to beginning a stroke action at the given
    position.
    
    :param tuple(int,int) ppos: Physical coordinates of stroke start.
    :rtype: Boolean
    :returns: True if the object can respond, False otherwise.
    
    This method is intended to be overridden.
    """
    return False

</t>
<t tx="leo.20181129171707.52">def _touchAsset(self, force = False):
    inputs = self._getInputs()
    changed = self._inputsChanged(inputs)
    if changed:
        self._saveInputs(inputs)
    if changed or force:
        self._updateAsset(self._buildAsset())


</t>
<t tx="leo.20181129171707.53">@abstractmethod
def _buildAsset(self):
    pass

</t>
<t tx="leo.20181129171707.54">from abc import ABCMeta, abstractmethod
from collections import namedtuple
from ggame.mathapp import MathApp
from ggame.sprite import Sprite
from ggame.asset import Color, LineStyle

</t>
<t tx="leo.20181129171707.55">class _MathDynamic(metaclass=ABCMeta):
    
    @others
</t>
<t tx="leo.20181129171707.56">def __init__(self):
    self._dynamic = False  # not switched on, by default!

</t>
<t tx="leo.20181129171707.57">def destroy(self):
    MathApp._removeDynamic(self)

</t>
<t tx="leo.20181129171707.58">def step(self):
    pass

</t>
<t tx="leo.20181129171707.59">def Eval(self, val):
    if callable(val):
        self._setDynamic() # dynamically defined .. must step
        return val
    else:
        return lambda : val  
        
</t>
<t tx="leo.20181129171707.6">@property
def scale(self):
    """
    Attribute reports the current view scale (pixels per logical unit).
    """
    return self._scale
    
</t>
<t tx="leo.20181129171707.60">def _setDynamic(self):
    MathApp._addDynamic(self)
    self._dynamic = True
        

</t>
<t tx="leo.20181129171707.61">class _MathVisual(Sprite, _MathDynamic, metaclass=ABCMeta):
    
    posinputsdef = []  # a list of names (string) of required positional inputs
    nonposinputsdef = []  # a list of names (string) of required non positional inputs
    defaultsize = 15
    defaultwidth = 200
    defaultcolor = Color(0, 1)
    defaultstyle = LineStyle(1, Color(0, 1))
    
    
    @others
</t>
<t tx="leo.20181129171707.62">def __init__(self, asset, *args, **kwargs):
    """
    Required inputs
    
    * **asset** a ggame asset
    * **args** the list of required positional and nonpositional arguments,
      as named in the posinputsdef and nonposinputsdef lists
    * **kwargs** all other optional keyword arguments:
      positioning - logical (default) or physical, size, width, color, style
      movable
    
    """
    
    MathApp._addVisual(self)
    #Sprite.__init__(self, asset, args[0])
    _MathDynamic.__init__(self)
    self._movable = False
    self._selectable = False
    self._strokable = False
    self.selected = False
    self.mouseisdown = False
    # 
    self.positioning = kwargs.get('positioning', 'logical')
    # positional inputs
    self.PI = namedtuple('PI', self.posinputsdef)
    # nonpositional inputs
    self.NPI = namedtuple('NPI', self.nonposinputsdef)
    # standard inputs (not positional)
    standardargs = ['size','width','color','style']
    self.SI = namedtuple('SI', standardargs)
    # correct number of args?
    if len(args) != len(self.posinputsdef) + len(self.nonposinputsdef):
        raise TypeError("Incorrect number of parameters provided")
    self.args = args
    # generated named tuple of functions from positional inputs
    self.posinputs = self.PI(*[self.Eval(p) for p in args][:len(self.posinputsdef)])
    self._getPhysicalInputs()
    # first positional argument must be a sprite position!
    Sprite.__init__(self, asset, self.pposinputs[0])
    # generated named tuple of functions from nonpositional inputs
    if len(self.nonposinputsdef) &gt; 0:
        self.nposinputs = self.NPI(*[self.Eval(p) for p in args][(-1*len(self.nonposinputsdef)):])
    else:
        self.nposinputs = []
    self.stdinputs = self.SI(self.Eval(kwargs.get('size', self.defaultsize)),
                                self.Eval(kwargs.get('width', self.defaultwidth)),
                                self.Eval(kwargs.get('color', self.defaultcolor)),
                                self.Eval(kwargs.get('style', self.defaultstyle)))
    self.sposinputs = self.PI(*[0]*len(self.posinputs))
    self.spposinputs = self.PI(*self.pposinputs)
    self.snposinputs = self.NPI(*[0]*len(self.nposinputs))
    self.sstdinputs = self.SI(*[0]*len(self.stdinputs))

</t>
<t tx="leo.20181129171707.63">def step(self):
    self._touchAsset()
    
</t>
<t tx="leo.20181129171707.64">def _saveInputs(self, inputs):
    self.sposinputs, self.spposinputs, self.snposinputs, self.sstdinputs = inputs
    
</t>
<t tx="leo.20181129171707.65">def _getInputs(self):
    self._getPhysicalInputs()
    return (self.PI(*[p() for p in self.posinputs]),
        self.PI(*self.pposinputs),
        self.NPI(*[p() for p in self.nposinputs]),
        self.SI(*[p() for p in self.stdinputs]))


</t>
<t tx="leo.20181129171707.66">def _getPhysicalInputs(self):
    """
    Translate all positional inputs to physical
    """
    pplist = []
    if self.positioning == 'logical':
        for p in self.posinputs:
            pval = p()
            try:
                pp = MathApp.logicalToPhysical(pval)
            except AttributeError:
                pp = MathApp._scale * pval
            pplist.append(pp)
    else:
        # already physical
        pplist = [p() for p in self.posinputs]
    self.pposinputs = self.PI(*pplist)

</t>
<t tx="leo.20181129171707.67">def _inputsChanged(self, saved):
    return self.spposinputs != saved[1] or self.snposinputs != saved[2] or self.sstdinputs != saved[3]


</t>
<t tx="leo.20181129171707.68">def destroy(self):
    MathApp._removeVisual(self)
    MathApp._removeMovable(self)
    MathApp._removeStrokable(self)
    _MathDynamic.destroy(self)
    Sprite.destroy(self)

</t>
<t tx="leo.20181129171707.69">def _updateAsset(self, asset):
    if type(asset) != ImageAsset:
        visible = self.GFX.visible
        if App._win != None:
            App._win.remove(self.GFX)
            self.GFX.destroy()
        self.asset = asset
        self.GFX = self.asset.GFX
        self.GFX.visible = visible        
        if App._win != None:
            App._win.add(self.GFX)
    self.position = self.pposinputs.pos
        
</t>
<t tx="leo.20181129171707.7">@property
def width(self):
    """
    Attribute reports the physical screen width (pixels).
    """
    return App._win.width

</t>
<t tx="leo.20181129171707.70">@property
def movable(self):
    return self._movable
    
</t>
<t tx="leo.20181129171707.71">@movable.setter
def movable(self, val):
    if not self._dynamic:
        self._movable = val
        if val:
            MathApp._addMovable(self)
        else:
            MathApp._removeMovable(self)

</t>
<t tx="leo.20181129171707.72">@property
def selectable(self):
    return self._selectable
    
</t>
<t tx="leo.20181129171707.73">@selectable.setter
def selectable(self, val):
    self._selectable = val
    if val:
        MathApp._addSelectable(self)
    else:
        MathApp._removeSelectable(self)

</t>
<t tx="leo.20181129171707.74">@property
def strokable(self):
    return self._strokable
    
</t>
<t tx="leo.20181129171707.75">@strokable.setter
def strokable(self, val):
    self._strokable = val
    if val:
        MathApp._addStrokable(self)
    else:
        MathApp._removeStrokable(self)

</t>
<t tx="leo.20181129171707.76">def select(self):
    self.selected = True


</t>
<t tx="leo.20181129171707.77">def unselect(self):
    self.selected = False
    
</t>
<t tx="leo.20181129171707.78">def mousedown(self):
    self.mouseisdown = True
    
</t>
<t tx="leo.20181129171707.79">def mouseup(self):
    self.mouseisdown = False

</t>
<t tx="leo.20181129171707.8">@width.setter
def width(self, value):
    pass

        
</t>
<t tx="leo.20181129171707.80">def processEvent(self, event):
    pass

# define how your class responds to mouse clicks - returns True/False
</t>
<t tx="leo.20181129171707.81">@abstractmethod
def physicalPointTouching(self, ppos):
    pass

# define how your class responds to being moved (physical units)
</t>
<t tx="leo.20181129171707.82">@abstractmethod
def translate(self, pdisp):
    pass

# define how your class responds to being stroked (physical units)
</t>
<t tx="leo.20181129171707.83">def stroke(self, ppos, pdisp):
    pass

# is the mousedown in a place that will result in a stroke?
</t>
<t tx="leo.20181129171707.84">def canstroke(self, ppos):
    return False

</t>
<t tx="leo.20181129171707.85">def _touchAsset(self, force = False):
    inputs = self._getInputs()
    changed = self._inputsChanged(inputs)
    if changed:
        self._saveInputs(inputs)
    if changed or force:
        self._updateAsset(self._buildAsset())


</t>
<t tx="leo.20181129171707.86">@abstractmethod
def _buildAsset(self):
    pass

</t>
<t tx="leo.20181129171707.87">from abc import ABCMeta, abstractmethod
from ggame.mathapp import _MathVisual, MathApp
from ggame.asset import Color, LineStyle, CircleAsset, ImageAsset


</t>
<t tx="leo.20181129171707.88">class _Point(_MathVisual, metaclass=ABCMeta):
    """
    Abstract base class for all point classes.
    
    :param Asset asset: A valid ggame Asset object
    :param tuple(float,float) pos: The position (physical or logical)
    """

    _posinputsdef = ['pos']
    _nonposinputsdef = []

    @others
</t>
<t tx="leo.20181129171707.89">def __init__(self, asset, *args, **kwargs):
    super().__init__(asset, *args, **kwargs)
    self._touchAsset()
    self.center = (0.5, 0.5)

</t>
<t tx="leo.20181129171707.9">@classmethod
def _addVisual(cls, obj):
    """ FIX ME """
    if isinstance(obj, _MathVisual):
        cls._mathVisualList.append(obj)
        
</t>
<t tx="leo.20181129171707.90">def __call__(self):
    return self._posinputs.pos()

</t>
<t tx="leo.20181129171707.91">def step(self):
    """
    Perform periodic processing.
    """
    self._touchAsset()

</t>
<t tx="leo.20181129171707.92">def physicalPointTouching(self, ppos):
    """
    Determine if a physical point is considered to be touching this point.
    
    :param tuple(int,int) ppos: Physical screen coordinates.
    :rtype: boolean
    :returns: True if touching, False otherwise.
    """
    return MathApp.distance(ppos, self._pposinputs.pos) &lt; self._sstdinputs.size
    
</t>
<t tx="leo.20181129171707.93">def translate(self, pdisp):
    """ 
    Perform necessary processing in response to being moved by the mouse/UI.
    
    :param tuple(int,int) pdisp: Translation vector (x,y) in physical screen
        units.
    :returns: None
    """
    ldisp = MathApp.translatePhysicalToLogical(pdisp)
    pos = self._posinputs.pos()
    self._posinputs = self._posinputs._replace(pos=self.Eval((pos[0] + ldisp[0], pos[1] + ldisp[1])))
    self._touchAsset()
    
</t>
<t tx="leo.20181129171707.94">def distanceTo(self, otherpoint):
    """
    Compute the distance to another :class:`_Point` object.
    
    :param _Point otherpoint: A reference to the other :class:`_Point`
    :rtype: float
    :returns: The distance (in logical units) to the other point
    """
    try:
        pos = self._posinputs.pos
        opos = otherpoint._posinputs.pos
        return MathApp.distance(pos, opos())
    except AttributeError:
        return otherpoint  # presumably a scalar - use this distance




</t>
<t tx="leo.20181129171707.95">class Point(_Point):
    """
    Basic point object representing any point in a geometrical sense. 
    An instantiated Point object is *callable* and will return a tuple
    with its logical position as an (x,y) pair.
    
    
    :param tuple(float,float) pos: Position in physical or logical units.

    :param \**kwargs:
        See below

    :Optional Keyword Arguments:
        * **positioning** (*str*) One of 'logical' (default) or 'physical'
        * **size** (*int*) Radius of the point (in pixels)
        * **color** (*Color*) Valid :class:`~ggame.asset.Color` object
        * **style** (*LineStyle*) Valid :class:`~ggame.asset.LineStyle` object
            
    Example::
    
        from ggame.asset import Color
        from ggame.point import Point
        from ggame.mathapp import MathApp

        p1 = Point((0,1), color=Color(0xff8000, 1.0))
        p1.movable = True
        # An orange point that can be moved
        
        p2 = Point(lambda: (p1()[0], p1()[1]+1))
        # A point position based on P1
        p3 = Point((1,0))
        # A third, fixed point
        
        MathApp().run()
    
    """
    _defaultsize = 5
    _defaultstyle = LineStyle(0, Color(0, 1))


    @others
</t>
<t tx="leo.20181129171707.96">def __init__(self, *args, **kwargs):
    super().__init__(CircleAsset(self._defaultsize, 
        self._defaultstyle, self._defaultcolor), *args, **kwargs)


</t>
<t tx="leo.20181129171707.97">def _buildAsset(self):
    return CircleAsset(self._stdinputs.size(),
                        self._stdinputs.style(),
                        self._stdinputs.color())



</t>
<t tx="leo.20181129171707.98">class ImagePoint(_Point):
    """
    :class:`~ggame.point.Point` object that uses an image as its on-screen
        representation.
    
    :param str url: Location of an image file (png, jpg)

    :param \*args:
        See below
    :param \**kwargs:
        See below

    :Required Arguments:
        * **pos** (*tuple(float,float)*) Position in physical or logical units.
    

    :Optional Keyword Arguments:
        * **positioning** (*str*) One of 'logical' (default) or 'physical'
        * **frame** (*Frame*) The sub-frame location of image within the image file
        * **qty** (*int*) The number of sub-frames, when used as a sprite sheet
        * **direction** (*str*) One of 'horizontal' (default) or 'vertical'
        * **margin** (*int*) Pixels between sub-frames if sprite sheet
    """


    @others
</t>
<t tx="leo.20181129171707.99">def __init__(self, url, *args, **kwargs):
    frame = kwargs.get('frame', None)
    qty = kwargs.get('qty', 1)
    direction = kwargs.get('direction', 'horizontal')
    margin = kwargs.get('margin', 0)
    self._imageasset = ImageAsset(url, frame, qty, direction, margin)
    super().__init__(self._imageasset, *args, **kwargs)


</t>
<t tx="leo.20181129171708.1">from time import time
from ggame.mathapp import MathApp, _MathDynamic

</t>
<t tx="leo.20181129171708.2">class Timer(_MathDynamic):
    
    @others
</t>
<t tx="leo.20181129171708.3">def __init__(self):
    super().__init__()
    self.once = []
    self.callbacks = {}
    self.reset()
    self.step()
    self.next = None
    MathApp._addDynamic(self)  # always dynamically defined
    
</t>
<t tx="leo.20181129171708.4">def reset(self):
    """
    Set the reference time to the MathApp current time. If the timer is used
    or initialized before the app, then set the reference time to match the
    system time instead.
    
    :returns: None
    """
    self._reset = MathApp.time
    if not self._reset:
        self._reset = time.time()
    
</t>
<t tx="leo.20181129171708.5">def step(self):
    nexttimers = []
    calllist = []
    self.time = MathApp.time - self._reset
    while self.once and self.once[0][0] &lt;= MathApp.time:
        tickinfo = self.once.pop(0)
        if tickinfo[1]:  # periodic?
            nexttimers.append((tickinfo[1], self.callbacks[tickinfo][0]))  # delay, callback
        calllist.append(self.callbacks[tickinfo].pop(0)) # remove callback and queue it
        if not self.callbacks[tickinfo]: # if the callback list is empty
            del self.callbacks[tickinfo] # remove the dictionary entry altogether
    for tickadd in nexttimers:
        self.callAfter(tickadd[0], tickadd[1], True)  # keep it going
    for call in calllist:
        call(self)

</t>
<t tx="leo.20181129171708.6">def callAfter(self, delay, callback, periodic=False):
    key = (MathApp.time + delay, delay if periodic else 0)
    self.once.append(key)
    callbacklist = self.callbacks.get(key, [])
    callbacklist.append(callback)
    self.callbacks[key] = callbacklist
    self.once.sort()
    
</t>
<t tx="leo.20181129171708.7">def callAt(self, time, callback):
    self.callAfter(time-self.time, callback)
    
</t>
<t tx="leo.20181129171708.8">def callEvery(self, period, callback):
    self.callAfter(period, callback, True)

</t>
<t tx="leo.20181129171708.9">def __call__(self):
    return self.time

</t>
<t tx="leo.20181130073250.1"></t>
<t tx="leo.20181130073306.1">@language html
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;&lt;game_title&gt;&gt;
&lt;link rel="shortcut icon" href="css/favicon.ico"&gt;    
&lt;link rel="stylesheet" type="text/css" href="css/bssite.css" media="screen" /&gt;
 
&lt;script type="text/javascript" src="static/jquery-3.3.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/jquery-ui.1.12.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/pixi-4.8.2.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/buzz-1.2.1.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython-3.7.0.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython_stdlib-3.7.0.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="text/javascript"&gt;
window.onload=function(){
brython({debug:1, pythonpath:['static']});
}
&lt;/script&gt;
&lt;script type="text/python"&gt;
@others
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</t>
<t tx="leo.20181130073306.2">&lt;title&gt;simple1&lt;/title&gt;

</t>
<t tx="leo.20181130073306.3">@language python
'''
# example 1
# 從 ggame 目錄中, 導入 App, ImageAsset 與 Sprite 模組
from ggame import (
    App, 
    ImageAsset, 
    Sprite, 
    LineAsset,
    LineStyle,
    Color
)
# Create a displayed object at 100,100 using an image asset
Sprite(ImageAsset("images/bunny.png"), (100,100))
# Create the app, with a default stage
app = App()  
# Run the app
app.run()
'''
'''
# example 2
from ggame import (
    App, 
    Color, 
    LineStyle, 
    Sprite, 
    RectangleAsset, 
    ImageAsset,
    CircleAsset, 
    EllipseAsset, 
    PolygonAsset,
)

# reverse - change the ball direction
def reverse(b):
    b.direction *= -1

# Set up function for handling screen refresh
def step():
    if ball.go:
        ball.x += ball.direction
        if ball.x + ball.width &gt; myapp.width or ball.x &lt; 0:
            ball.x -= ball.direction
            reverse(ball)

myapp = App()

# Three primary colors with no transparency (alpha = 1.0)
red = Color(0xff0000, 1.0)
green = Color(0x00ff00, 1.0)
blue = Color(0x0000ff, 1.0)
black = Color(0x000000, 1.0)

# Define a line style that is a thin (1 pixel) wide black line
thinline = LineStyle(1, black)
# A graphics asset that represents a rectangle
rectangle = RectangleAsset(50, 20, thinline, blue)

# define colors and line style
green = Color(0x00ff00, 1)
black = Color(0, 1)
noline = LineStyle(0, black)
# a rectangle asset and sprite to use as background
bg_asset = RectangleAsset(myapp.width, myapp.height, noline, green)
bg = Sprite(bg_asset, (0,0))

# Now display a rectangle
Sprite(rectangle)

# A ball! This is already in the ggame-tutorials repository
ball_asset = ImageAsset("images/orb-150545_640.png")
ball = Sprite(ball_asset, (0, 0))
# Original image is too big. Scale it to 1/10 its original size
ball.scale = 0.1
# custom attributes
ball.direction = 1
ball.go = True

myapp.run(step)
'''

# example 3
from ggame import (
    App, 
    Color, 
    Sound,
    LineStyle, 
    Sprite, 
    RectangleAsset, 
    ImageAsset,
    CircleAsset, 
    EllipseAsset, 
    PolygonAsset,
    SoundAsset,
)

myapp = App()

# define colors and line style
green = Color(0x00ff00, 1)
black = Color(0, 1)
noline = LineStyle(0, black)
# a rectangle asset and sprite to use as background
bg_asset = RectangleAsset(myapp.width, myapp.height, noline, green)
bg = Sprite(bg_asset, (0,0))
# A ball! This is already in the ggame-tutorials repository
ball_asset = ImageAsset("images/orb-150545_640.png")
ball = Sprite(ball_asset, (0, 0))
# Original image is too big. Scale it to 1/10 its original size
ball.scale = 0.1
# custom attributes
ball.direction = 10
ball.go = True
# Sounds
pew1_asset = SoundAsset("sounds/pew1.mp3")
pew1 = Sound(pew1_asset)
pop_asset = SoundAsset("sounds/reappear.mp3")
pop = Sound(pop_asset)

# reverse - change the ball direction
def reverse(b):
    #pop.play()
    b.direction *= -1

def ball_y_down():
    ball.y += 3
    
def ball_y_up():
    ball.y -= 3

# Set up function for handling screen refresh
def step():
    if ball.go:
        ball.x += ball.direction
        if ball.x + ball.width &gt; myapp.width or ball.x &lt; 0:
            ball.x -= ball.direction
            reverse(ball)

# Handle the space key
def spaceKey(event):
    ball.go = not ball.go

# Handle the "reverse" key
def reverseKey(event):
    reverse(ball)
    
def ballDown(event):
    ball_y_down()
    
def ballUp(event):
    ball_y_up()

# Handle the mouse click
def mouseClick(event):
    pew1.play()
    ball.x = event.x
    ball.y = event.y
    
# Set up event handlers for the app
myapp.listenKeyEvent('keydown', 'space', spaceKey)
myapp.listenKeyEvent('keydown', 'r', reverseKey)
myapp.listenMouseEvent('click', mouseClick)

myapp.listenKeyEvent('keydown', 'down arrow', ballDown)
myapp.listenKeyEvent('keydown', 'up arrow', ballUp)
    
myapp.run(step)

'''
# example 4
from ggame import App, Color, LineStyle, Sprite
from ggame import CircleAsset

red = Color(0xff0000, 1.0)
green = Color(0x00ff00, 1.0)
blue = Color(0x0000ff, 1.0)
black = Color(0x000000, 1.0)

thinline = LineStyle(1, black)
mycircle = CircleAsset(5, thinline, blue)
xcoordinates = list(range(100, 600, 10))

# Generate a list of sprites that form a line!
sprites = [Sprite(mycircle, (x, x*0.5 + 100)) for x in xcoordinates]

myapp = App()
myapp.run()
'''
'''
# example 5
from ggame import (
    App, 
    Color, 
    Sound,
    LineStyle, 
    Sprite, 
    LineAsset,
    RectangleAsset, 
    ImageAsset,
    CircleAsset, 
    EllipseAsset, 
    PolygonAsset,
    SoundAsset,
)

from ggame.point import Point
from ggame.line import LineSegment
from ggame.mathapp import MathApp

#p1 = Point((0,1), color=Color(0xff8000, 1.0))
#p1.movable = True
p1 = Point((200,200))
ls = LineSegment(p1, Point((300,300)))

# Three primary colors with no transparency (alpha = 1.0)
red = Color(0xff0000, 1.0)
green = Color(0x00ff00, 1.0)
blue = Color(0x0000ff, 1.0)
black = Color(0x000000, 1.0)

# Define a line style that is a thin (1 pixel) wide black line
thinline = LineStyle(1, black)
# A graphics asset that represents a rectangle
rectangle = RectangleAsset(50, 20, thinline, blue)
line = LineAsset(100, 100, LineStyle(1, blue))

# Now display a rectangle
Sprite(rectangle)
Sprite(line)


myapp = App()
myapp.run()
'''
</t>
<t tx="leo.20181130105336.1">https://github.com/BrythonServer/ggame

更新為下列版本, 目前仍只能用於 Pixi.js 3.0.5 版, 必須更新為 Pixi.js 4
https://github.com/BrythonServer/ggame/tree/6ccee8f01711b94273e929380ff4d19a4b505991</t>
<t tx="leo.20181130214116.1">@language html
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;&lt;game_title&gt;&gt;
&lt;link rel="shortcut icon" href="css/favicon.ico"&gt;    
&lt;link rel="stylesheet" type="text/css" href="css/bssite.css" media="screen" /&gt;
 
&lt;script type="text/javascript" src="static/jquery-3.3.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/jquery-ui.1.12.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/pixi-4.8.2.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/buzz-1.2.1.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython-3.7.0.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython_stdlib-3.7.0.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="text/javascript"&gt;
window.onload=function(){
brython({debug:1, pythonpath:['static']});
}
&lt;/script&gt;
&lt;script type="text/python"&gt;
@others
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</t>
<t tx="leo.20181130214116.2">&lt;title&gt;Conway&lt;/title&gt;

</t>
<t tx="leo.20181130214116.3">@language python
# example 6
# Exemplar implementation of the Conway's Life Project

from ggame import CircleAsset, Color, LineStyle, Sprite
from ggame import App

red = Color(0xff0000, 1.0)
blue = Color(0x0000ff, 1.0)
black = Color(0,1.0)

CELLDIAMETER = 10
redcircle = CircleAsset(CELLDIAMETER/2, LineStyle(0, black), red)
bluecircle = CircleAsset(CELLDIAMETER/2, LineStyle(0, black), blue)

deadcells = []
livecells = {}
neighborsof = {}
killlist = []
birthlist = []

# logical screen shift
screenoffset = (0,0)

# physical coordinates from logical
pfroml = lambda p: (p[0]*CELLDIAMETER, p[1]*CELLDIAMETER)
# logical coordinates from physical
lfromp = lambda p: (p[0]//CELLDIAMETER, p[1]//CELLDIAMETER)
adjacentdelta = [(-1,-1), (0,-1), (1,-1), (-1,0), (1,0), (-1,1), (0,1), (1,1)]
adjacentcoords = lambda pos, delta: [(pos[0]+x[0], pos[1]+x[1]) for x in delta]

def GetAdjacent(coords):
    # build a list of adjacentcoordinates
    try:
        neighbors = neighborsof[coords]
    except:
        # build a list of adjacent coordinates
        neighbors = adjacentcoords(coords, adjacentdelta)
        neighborsof[coords] = neighbors
    return neighbors

def NewCellAt(coords):
    global screenoffset
    if not coords in livecells:
        try:
            newcell = deadcells.pop()
        except:
            newcell = (Sprite(redcircle,(0,0)), Sprite(bluecircle,(0,0)))
        livecells[coords] = newcell
        newcell[0].position = newcell[1].position = pfroml((coords[0]+screenoffset[0], coords[1]+screenoffset[1]))
        newcell[0].visible = True
        newcell[1].visible = False

# return number of live neighbors and list of empty neighbors
def ScanCell(coords):
    neighbors = GetAdjacent(coords)
    count = 0
    empties = []
    for n in neighbors:
        if n in livecells:
            count = count + 1
        else:
            empties.append(n)
    return count, empties


def step():
    global killlist
    global birthlist
    global running

    if not running:
        return
    allempties = set()
    # scan living cells
    for p, val in livecells.items():
        # change reds to blue
        if val[0].visible:
            val[0].visible = False
            val[1].visible = True
        n, empties = ScanCell(p)
        if n &gt; 3 or n &lt; 2:
            killlist.append(p)
        allempties.update(empties)
    # scan all neighboring empty cells to find newbies
    for p in allempties:
        n, empties = ScanCell(p)
        if n == 3:
            birthlist.append(p)
    # process deaths
    for p in killlist:
        c = livecells.pop(p)
        c[0].visible = c[1].visible = False
        deadcells.append(c)
    # process births
    for p in birthlist:
        NewCellAt(p)
    
    # clean up
    killlist = []
    birthlist = []
        
"""
def MakeAGlider(pos):
    deltas = [(0,0), (1,1), (2,1), (2,0), (2,-1)]
    for p in deltas:
        NewCellAt((pos[0]+p[0],pos[1]+p[1]))

for i in range(5):
    MakeAGlider((i*6, i*2))
"""

mousedown = None
running = False

def MouseDown(event):
    global mousedown
    global screenoffset
    mousedown = True
    pos = lfromp((event.x, event.y))
    NewCellAt((pos[0]-screenoffset[0], pos[1]-screenoffset[1]))

def MouseUp(event):
    global mousedown
    mousedown = False

def MouseMove(event):
    global screenoffset
    if mousedown:
        pos = lfromp((event.x, event.y))
        NewCellAt((pos[0]-screenoffset[0], pos[1]-screenoffset[1]))
        
def Spacebar(event):
    global running
    if running:
        running = False
    else:
        running = True

def Left(event):
    global screenoffset
    screenoffset = (screenoffset[0]-1, screenoffset[1])
    Move()
    
def Right(event):
    global screenoffset
    screenoffset = (screenoffset[0]+1, screenoffset[1])
    Move()
    
def Up(event):
    global screenoffset
    screenoffset = (screenoffset[0], screenoffset[1]-1)
    Move()
    
def Down(event):
    global screenoffset
    screenoffset = (screenoffset[0], screenoffset[1]+1)
    Move()
    
def Move():
    global screenoffset
    for p, val in livecells.items():
        pphys = pfroml((p[0]+screenoffset[0],p[1]+screenoffset[1]))
        val[0].position = pphys
        val[1].position = pphys

App.listenMouseEvent('mousedown', MouseDown)
App.listenMouseEvent('mouseup', MouseUp)
App.listenMouseEvent('mousemove', MouseMove)
App.listenKeyEvent('keypress', 'space', Spacebar)
App.listenKeyEvent('keydown', 'left arrow', Left)
App.listenKeyEvent('keydown', 'right arrow', Right)
App.listenKeyEvent('keydown', 'up arrow', Up)
App.listenKeyEvent('keydown', 'down arrow', Down)

print("Press &lt;space&gt; to start and stop.")
print("Use mouse to set initial living cells.")
print("Use cursor keys to move the screen.")


myapp = App()
myapp.run(step)

</t>
<t tx="leo.20181203150038.1">@language html
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;meta charset="UTF-8"&gt;
&lt;&lt;game_title&gt;&gt;
&lt;link rel="shortcut icon" href="css/favicon.ico"&gt;    
&lt;link rel="stylesheet" type="text/css" href="css/bssite.css" media="screen" /&gt;
 
&lt;script type="text/javascript" src="static/jquery-3.3.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/jquery-ui.1.12.1.min.js" &gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/pixi-4.8.2.min.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/buzz-1.2.1.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython-3.7.0.js"&gt;&lt;/script&gt;
&lt;script type="text/javascript" src="static/brython_stdlib-3.7.0.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;script type="text/javascript"&gt;
window.onload=function(){
brython({debug:1, pythonpath:['static']});
}
&lt;/script&gt;
&lt;script type="text/python"&gt;
@others
&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;

</t>
<t tx="leo.20181203150038.2">&lt;title&gt;no.1&lt;/title&gt;

</t>
<t tx="leo.20181203150038.3">@language python
# 導入模組
from ggame import App, ImageAsset, Sprite, MouseEvent
from ggame import Color, Sound, LineStyle, RectangleAsset, CircleAsset, PolygonAsset, SoundAsset
from random import random, randint

up = 0
q = 0
life = 0
i = 0

def w(event):
     global up
     up = 1
    
def d(event):
     global q
     q = 1
    
def a(event):
     global life
     life = 1
     
class Bunny(Sprite):
    
    asset = ImageAsset("images/1122.png")
    
    
    def __init__(self, position):
        super().__init__(Bunny.asset, position)
        # register mouse events
        App.listenKeyEvent('keydown', 'w', w)
        App.listenKeyEvent('keydown', 'd', d)
        App.listenKeyEvent('keydown', 'a', a)
        self.scale = 0.12



    def step(self):
        global up
        global i
        global q
        global life
        
        if q and self.x &lt; 1750:
            self.x += 50
            q -= 1
            
        if life and self.x &gt; 50:
            self.x -= 50
            life -= 1
        if i:
            self.y += 10
            if self.y &gt; 680:
                i =0
        if up and self.y &gt; 0:
            self.y -= 10
        if self.y &lt; 100:
            up -= 1
            i += 1

            

class Sun(Sprite):

    asset = ImageAsset("images/12.png")
    width = 80
    height = 76
    
    def __init__(self, position):
        super().__init__(Sun.asset, position)
        
    def step(self):
            self.x = 800
            self.y = 200

class Sun2(Sprite):

    asset = ImageAsset("images/12.png")
    width = 80
    height = 76
    
    def __init__(self, position):
        super().__init__(Sun2.asset, position)
        
    def step(self):
            self.x = 1300
            self.y = 200
            
class Sun3(Sprite):

    asset = ImageAsset("images/12.png")
    width = 80
    height = 76
    
    def __init__(self, position):
        super().__init__(Sun3.asset, position)
        
    def step(self):
            self.x = 300
            self.y = 200
            
class A(Sprite):

    asset = ImageAsset("images/1212.png")
    width = 80
    height = 76
    
    def __init__(self, position):
        super().__init__(A.asset, position)
        
    def step(self):
            self.x = 800
            self.y = 200
            
class A2(Sprite):

    asset = ImageAsset("images/1212.png")
    width = 80
    height = 76
    
    def __init__(self, position):
        super().__init__(A2.asset, position)
        
    def step(self):
            self.x = 1300
            self.y = 200

class A3(Sprite):

    asset = ImageAsset("images/1212.png")
    width = 80
    height = 76
    
    def __init__(self, position):
        super().__init__(A3.asset, position)
        
    def step(self):
            self.x = 300
            self.y = 200
            
class DemoApp(App):
    
    def __init__(self):
        super().__init__()
        self.sun = Sun((self.width/2, self.height/2))
        self.sun2 = Sun2((self.width/2, self.height/2))
        self.sun3 = Sun3((self.width/2, self.height/2))
        Bunny((900,700))
        self.A = A((self.width/2, self.height/2))
        self.A2 = A2((self.width/2, self.height/2))
        self.A3 = A3((self.width/2, self.height/2))

    def step(self):
        """
        Override step to perform action on each frame update
        """
        for bunny in self.spritelist:
            bunny.step()



# Create the app
app = DemoApp()  
# Run the app
app.run()

</t>
</tnodes>
</leo_file>
